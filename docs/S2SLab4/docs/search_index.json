[["index.html", "S2S Lab 4 1 Qualitative Data 1.1 Tables 1.2 Barplots 1.3 Dot Charts 1.4 Pie Charts 1.5 Bivariate Data", " S2S Lab 4 1 Qualitative Data Qualitative data is the term used when a variable has different categories or groups or levels. This could be things such as students' grades, the genders of patients in an experiment or which treatment subjects have been given. There are several ways that qualitative data can be summarised and presented. 1.1 Tables Frequency tables summarise qualitative data by showing the different groups/categories in a variable and the corresponding frequency with which they occur - that is, how many observations fall into each category. Frequency tables can be created in R using the table() function. We have already seen table() used in Lab 3, but let's revisit it with an example. The data set EPIDURAL from the package PASWR2 contains information on 85 patients from a study used to determine whether administering epidural anesthesia (a pain relief administered in the back) to pregnant women in labour is better whilst they are in the traditional sitting position, or when they are in a \"hamstring stretch\" position. This contains several variables relating to each patient and the treatment they receive (to see more about what each of these variables describes, run the code help(\"EPIDURAL\")). We can load the data frame into our Environment tab and look at the first five rows using the following code (make sure you have installed the PASWR2 package on whatever device you are using R with beforehand). library(PASWR2) data(&quot;EPIDURAL&quot;) head(EPIDURAL) doctor kg cm ease treatment oc complications Dr. B 116 172 Difficult Traditional Sitting 0 None Dr. C 86 176 Easy Hamstring Stretch 0 None Dr. B 72 157 Difficult Traditional Sitting 0 None Dr. B 63 169 Easy Hamstring Stretch 2 None Dr. B 114 163 Impossible Traditional Sitting 0 None Dr. B 121 163 Difficult Hamstring Stretch 3 None The variable ease is a factor variable which tells how easy the physician found it to locate where the epidural anesthesia should be administered for each patient. It has levels \"Easy\", \"Difficult\" and \"Impossible\". We can summarise the number of patients that fall into each level of the ease variable using the table() function as follows. epi_freq &lt;- table(EPIDURAL$ease) epi_freq Difficult Easy Impossible 20 57 8 This frequency table shows us that there are 57 patients in the data set for whom it was easy to administer the anesthetic, 20 who it was difficult for and 8 for whom it was impossible to find where to administer the anesthetic. The levels of ease are automatically presented in alphabetical order. Can you reorder the labels so that they go in the order \"Easy\", \"Difficult\" and \"Impossible\"? Solution EPIDURAL$ease &lt;- factor(x = EPIDURAL$ease, levels = c(&quot;Easy&quot;, &quot;Difficult&quot;, &quot;Impossible&quot;)) levels(EPIDURAL$ease) [1] &quot;Easy&quot; &quot;Difficult&quot; &quot;Impossible&quot; The function levels() can be used to see the levels of a factor variable, as well as the order they are stored in. We can update the frequency table epi_freq so that the different levels of ease now appear in a sensible order. epi_freq &lt;- table(EPIDURAL$ease) epi_freq Easy Difficult Impossible 57 20 8 We could also create a table showing the proportion of the total number of patients which fall into each level of ease using prop.table(). We need to make sure that we give a pre-existing table to this function. We can use the table epi_freq created in the question above here. epi_prop &lt;- prop.table(epi_freq) epi_prop Easy Difficult Impossible 0.67058824 0.23529412 0.09411765 Now we can see that it was easy to find where to administer the anesthetic for roughly 67% of patients, difficult for roughly 24% and impossible for 9% of patients. The TITANIC3 data set from the PASWR2 package contains information on the survival status of passengers on the Titanic. Load this data set into your Environment tab and create a frequency table showing the number of passengers who survived and the number who did not. Remember to explore the data set using the help() and str() functions. It might help to rename the levels of the survived variable so they are clear. Solution data(&quot;TITANIC3&quot;) TITANIC3$survived &lt;- factor(x = TITANIC3$survived, labels = c(&quot;No&quot;, &quot;Yes&quot;)) table(TITANIC3$survived) No Yes 809 500 What proportion of passengers survived the Titanic sinking? Solution We can find the proportion of survivors by using the prop.table() function. prop.table(table(TITANIC3$survived)) No Yes 0.618029 0.381971 1.2 Barplots Barplots are a way to graphically summarise qualitative data. You will most likely have seen many barplots before, but now we're going to learn how to create our own. The function used to create barplots in R is barplot(). It takes the following arguments: height =: this is the vector or matrix which contains a summary of the qualitative data; this could be a frequency table or a table of proportions. col =: this is a vector of colours to be used for the bars in the barplot. If you want to see a list of colour names that R can use, run the code colors() - there are also documents online which will show you the actual colours too! main =: this is the main title of the plot. xlab =: this is a label for along the x-axis. ylab =: this is a label for along the y-axis. ylim =: this is a vector giving the limits that the y-axis should be spread over. The only essential argument to give to barplot() is height =. For a full list of the arguments that can be used within barplot(), use the code help(\"barplot\"). We can create a barplot showing the number of patients from EPIDURAL that fall into each level of ease using the following code. barplot(height = epi_freq, col = c(&quot;darkslategray&quot;, &quot;darkslategray4&quot;, &quot;darkslategray3&quot;), main = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;, xlab = &quot;Ease&quot;, ylab = &quot;Frequency&quot;) We can also use the table of proportions epi_prop to create a barplot, this time showing the proportion of patients in each level of ease, rather than the frequency. barplot(height = epi_prop, col = c(&quot;darkslategray&quot;, &quot;darkslategray4&quot;, &quot;darkslategray3&quot;), main = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;, xlab = &quot;Ease&quot;, ylab = &quot;Proportion&quot;) Notice that the shapes of both these barplots are identical. The only difference between them is the scale used on the y-axis. Complete the code below to create a barplot which shows the number of passengers on the Titanic belonging to 1st, 2nd and 3rd class respectively. (height =, col = c(&quot;gray32&quot;, &quot;gray95&quot;, &quot;seashell3&quot;), main = &quot;Number of Titanic Passengers in each Class&quot;, xlab = &quot;Class&quot;, ylab = &quot;Frequency&quot;) Solution barplot(height = table(TITANIC3$pclass), col = c(&quot;gray32&quot;, &quot;gray95&quot;, &quot;seashell3&quot;), main = &quot;Number of Titanic Passengers in each Class&quot;, xlab = &quot;Class&quot;, ylab = &quot;Frequency&quot;) 1.3 Dot Charts Dot charts show similar information to barplots and summarise qualitative data. They show a dot for each level of a categorical variable which indicates the frequency of that level (see below for an example). Dot charts can be made in R using the function dotchart(). This takes similar arguments to those used by barplot() above, including: x =: this is the vector or matrix which contains a summary of the qualitative data; this could be a frequency table or a table of proportions. bg =: this is the colour to be used inside the dot. Again, the only essential argument to provide is x =. We can create a dot chart showing the number of patients from EPIDURAL in each level of ease using the following code. dotchart(x = epi_freq, bg = c(&quot;darkslategray&quot;, &quot;darkslategray4&quot;, &quot;darkslategray3&quot;), main = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;, xlab = &quot;Frequency&quot;, ylab = &quot;Ease&quot;) 1.4 Pie Charts A third way to graphically present qualitative data is with a pie chart. These show the relative frequencies of different levels of a categorical variable as proportions of a \"pie\". Pie charts are sometimes not favoured by statisticians because it can be difficult to clearly see the differences in proportions when they are very similar. Pie charts can still be used though to show the proportion of observations in a category, in relation to the total number of observations. The function used to create pie charts is pie(), which takes the following arguments: x =: this is the vector which summarises the qualitative data as frequencies or proportions. radius =: this determines the size of the pie chart within your plotting window. col =: this is a vector of colours which are to be used for each \"slice\" of the pie chart. You can see a full list of the arguments that can be given to the pie() function using help(\"pie\"). The only necessary argument to provide is x =. We can create a pie chart showing the proportion of patients in each level of ease using the code below. pie(x = epi_prop, radius = 0.9, col = c(&quot;darkslategray&quot;, &quot;darkslategray4&quot;, &quot;darkslategray3&quot;), main = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;) Create a pie chart showing the proportion of passengers on the Titanic in each class. Solution pie(x = table(TITANIC3$pclass), col = c(&quot;gray32&quot;, &quot;gray95&quot;, &quot;seashell3&quot;), main = &quot;Class of Titanic Passengers&quot;) For more details on summarising univariate qualitative data and creating suitable graphical displays, see Section 2.3 Displaying Qualitative Data in Probability and Statistics with R. 1.5 Bivariate Data So far, we have looked at different ways to visualise information about one categorical (or qualitative) variable. Because only one variable has been considered, it is called univariate data. We will now turn our attention to bivariate categorical data. This means we will look at ways to visualise information about two categorical variables at the same time. We can expand upon some of the methods we have already learned to allow two categorical variables to be considered. In Section 1.1 we looked at the use of the table() function to create frequency tables for one categorical variable. We can expand upon the use of this function so that frequency tables of two categorical variables can be created. These are known as two-way contingency tables. In order to create a two-way contingency table, simply provide the second categorical variable you wish to use as an additional argument. The data set EPIDURAL contains a variable doctor which indicates the physician (\"Dr. A\", \"Dr. B\", \"Dr. C\" or \"Dr. D\") who administered the epidural anesthesia. Table 1.1 shows the number of patients who fall into each level of the doctor and ease variables. Table 1.1: Two-way contingency table of Doctor by Ease. Easy Difficult Impossible Dr. A 19 3 1 Dr. B 7 10 4 Dr. C 18 3 0 Dr. D 13 4 3 We can recreate Table 1.1 in R using the following code. epi_tab &lt;- table(EPIDURAL$doctor, EPIDURAL$ease) epi_tab Easy Difficult Impossible Dr. A 19 3 1 Dr. B 7 10 4 Dr. C 18 3 0 Dr. D 13 4 3 Create a two-way contingency table showing the number of passengers who survived and did not survive in each of the three classes (1st, 2nd and 3rd). Solution table(TITANIC3$pclass, TITANIC3$survived) No Yes 1st 123 200 2nd 158 119 3rd 528 181 How many 3rd class passengers survived the sinking of the Titanic? Barplots are a useful tool to present the information from a two-way contingency table graphically. For example, we can produce a barplot, which shows the same counts as in Table 1.1, using the following code. barplot(height = epi_tab, legend.text = TRUE, col = c(&quot;seashell&quot;, &quot;rosybrown2&quot;, &quot;thistle&quot;, &quot;snow4&quot;), main = &quot;Number of patients treated by each physician in each level of Ease&quot;, xlab = &quot;Ease&quot;, ylab = &quot;Frequency&quot;) This code uses the barplot() function introduced in Section 1.2 and provides the two-way contingency table epi_tab to the argument height =. This means that all the values in this table will be used to construct the height of the bars. Because the bars for each doctor are on top of each other, this is known as a \"stacked\" barplot. The argument legend.text = TRUE has also been included so that a legend, indicating the different physicians, is included in the plot. If we instead wanted to produce a barplot where there is a separate bar for each doctor within each level of the ease variable, then we need to include the argument beside = TRUE. barplot(height = epi_tab, legend.text = TRUE, beside = TRUE, col = c(&quot;seashell&quot;, &quot;rosybrown2&quot;, &quot;thistle&quot;, &quot;snow4&quot;), main = &quot;Number of patients treated by each physician in each level of Ease&quot;, xlab = &quot;Ease&quot;, ylab = &quot;Frequency&quot;) Another option for presenting this information would be to create a barplot where the different doctors are along the x-axis and the levels of ease are used to create the individual bars. In order to do this, we need to transpose the two-way contingency table that is given to the height = argument in the barplot() function. Transposing a table can easily be achieved using the function t(). The only argument needed is the table you wish to transpose. t(epi_tab) Dr. A Dr. B Dr. C Dr. D Easy 19 7 18 13 Difficult 3 10 3 4 Impossible 1 4 0 3 We can then create the following barplots using the transposed epi_tab table. barplot(height = t(epi_tab), legend.text = TRUE, col = c(&quot;darkslategray&quot;, &quot;darkslategray3&quot;, &quot;darkslategray4&quot;), main = &quot;Number of patients treated by each physician in each level of Ease&quot;, xlab = &quot;Doctor&quot;, ylab = &quot;Frequency&quot;) barplot(height = t(epi_tab), legend.text = TRUE, beside = TRUE, col = c(&quot;darkslategray&quot;, &quot;darkslategray3&quot;, &quot;darkslategray4&quot;), main = &quot;Number of patients treated by each physician in each level of Ease&quot;, xlab = &quot;Doctor&quot;, ylab = &quot;Frequency&quot;) It is often better to present relationships using proportions, rather than counts. In order to calculate the proportions (either out of the total number of observations, row totals or column totals) from a two-way contingency table, we can use the function prop.table(). To create a barplot which shows the proportion of patients who were in each level of the ease variable out of the total number of patients seen by a given doctor, we would first need to calculate these proportions in epi_tab. This can be done by using the argument margin = 1 within the prop.table() function. epi_prop_tab &lt;- prop.table(x = epi_tab, margin = 1) epi_prop_tab Easy Difficult Impossible Dr. A 0.82608696 0.13043478 0.04347826 Dr. B 0.33333333 0.47619048 0.19047619 Dr. C 0.85714286 0.14285714 0.00000000 Dr. D 0.65000000 0.20000000 0.15000000 Now we can see, for example, that Dr. A found it easy to feel the bone landmarks of 82.6% of their patients, found it difficult in 13.0% of their patients and impossible in 4.3% of their patients. We can graphically present these proportions for all doctors in a barplot using the following code. Because the proportions are calculated out of the total number of patients each doctor has seen, it makes sense to plot the physicians along the x-axis. barplot(height = t(epi_prop_tab), legend.text = TRUE, beside = TRUE, col = c(&quot;darkslategray&quot;, &quot;darkslategray3&quot;, &quot;darkslategray4&quot;), main = &quot;Proportion of doctor&#39;s patients in each level of Ease variable&quot;, xlab = &quot;Doctor&quot;, ylab = &quot;Proportion&quot;) Create a barplot showing the proportion of passengers in each class who survived and the proportion who did not. Make sure the bars are side-by-side, and that the \"class\" variable is shown along the x-axis. Solution surv_prop &lt;- prop.table(table(TITANIC3$pclass, TITANIC3$survived), margin = 1) barplot(height = t(surv_prop), legend.text = TRUE, beside = TRUE, main = &quot;Proportion of Passengers Surviving the Titanic Sinking in each Class&quot;, xlab = &quot;Class&quot;, ylab = &quot;Proportion&quot;) "],["quant.html", "2 Quantitative Data 2.1 Stem and Leaf Plots 2.2 Strip Charts 2.3 Histograms 2.4 Kernel Density Estimators", " 2 Quantitative Data Quantitative data is the term used to describe numerical data. Essentially, data that can be \"quantified\" is quantitative data. That is, any information that can be measured, counted or given a numerical value. This could be things such as individuals' height, weight or age, or distances or prices of items. Quantitative data can be thought of having different \"properties\", including its shape, center and spread. There are several ways in which quantitative data can be presented to better understand these properties. 2.1 Stem and Leaf Plots When dealing with quantitative data, a good way to quickly get an idea of the spread of the data is with a stem and leaf plot. This arranges the observations by increasing numerical value and splits each value into a \"stem\" and a \"leaf\". The stem is the beginning of the numerical value - this could be multiples of 10, 100, 1000 or any value really. The leaf is always a single digit, indicating the value of the observation from the data. Stem and leaf plots can become increasingly hard to read when using larges data sets. They are clearest, and easiest to interpret, when they are constructed for relatively small data sets (fewer than 100 observations roughly). The function for creating a stem and leaf plot in R is stem(). The only necessary argument for this function is x = which is the vector of the numeric values. We can create a stem and leaf plot showing the weight (in kg) of each patient included in the EPIDURAL data set using the following code. The weights are stored in the variable called kg. stem(x = EPIDURAL$kg, scale = 2) The decimal point is 1 digit(s) to the right of the | 4 | 8 5 | 77999 6 | 0133567779 7 | 01122244455679999 8 | 001233334455566666799 9 | 000011233445678 10 | 334568 11 | 23446 12 | 1 13 | 14 14 | 2 15 | 16 | 8 The first row in this plot tells us that the lightest patient is 48kg, the second lightest is 57kg, then 57kg and so on. The argument scale = 2 has been included so that the stem shows a new row for every 10kg in weight. The stem may not always be multiples of 10, so pay close attention to the message given The decimal point is 1 digit(s) to the right of the | which will tell you where the decimal point lies. How would you describe the shape of the distribution of patients' weights? Left-skewedSymmetricRight-skewedCan't tell 2.2 Strip Charts A strip chart is an alternative to stem and leaf plots. It is sometimes called a dotplot (not to be confused with a dot chart for qualitative data) because dots are placed in the plot for each numeric value of the quantitative data. This is good for visualising one numeric variable on a plot. Strip charts can be created in R using the function stripchart(). This function takes the arguments: x =: this is the vector of numeric values or a list of vectors. data =: this is the data frame that the vector of numeric values comes from (if it is a variable in a data frame). method =: this is the method used to separate points which represent the same value. Values you can provide to this arguments include \"overplot\" (this is the default), which plots points directly on top of each other, \"jitter\" which randomly moves points away from their true value by a small amount so individual points can be seen, or \"stack\" which stacks points above each other. offset =: when method = \"stack\", this argument specifies the size of the gap that should be between points which are stacked above others. pch =: this is the plotting character (i.e. the shape) to be used for the points. By default this takes the value 0 which means the points will be square. This argument can take any value from 0 to 25 which all represent different shapes or symbols. We can create a strip chart showing the weight of all patients in the EPIDURAL data set using the following code. This code stacks the points which represent patient's of the same weight above each other, making it easier to see the shape of the data. stripchart(x = EPIDURAL$kg, method = &quot;stack&quot;, offset = 0.5, pch = 1, col = &quot;coral1&quot;, main = &quot;Patients Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;) Again, we can see that the patients' weights are right skewed. Strip charts can also be used to visualise numeric data, split across different levels of a categorical variable. For example, we can show the weight of patients in each level of the ease variable using the following code. stripchart(x = kg ~ ease, data = EPIDURAL, method = &quot;stack&quot;, offset = 0.5, pch = 19, col = c(&quot;darkslategray&quot;, &quot;darkslategray3&quot;, &quot;darkslategray4&quot;), main = &quot;Patient Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;, ylab = &quot;Ease&quot;) Note here that we have provided a \"formula\" to the argument x =. This is of the form x ~ g where x is the vector of numeric values (in this case kg), and g is the vector containing the groups to be used to split up the data (the variable ease here). We have also changed pch = to be 19 which tells R to use filled circles for each point, rather than the empty circles like when pch = 1. When splitting the weights of all the patients into the three levels of ease, the right skew seen in the weights before, is no longer apparent. In general it seems that for lighter weight patients, it is easier to find the location to administer the epidural anesthetic and that as patients get heavier, finding the right location becomes more difficult. Complete the code below to create a stripchart showing the distribution of passenger ages in each class on board the Titanic. stripchart(x =, data = TITANIC3, method =, pch = 20, col = c(&quot;gray32&quot;, &quot;gray95&quot;, &quot;seashell3&quot;), main = &quot;Ages of Passengers on the Titanic&quot;, xlab = &quot;Age&quot;, ylab = &quot;Class&quot;) Solution stripchart(x = age ~ pclass, data = TITANIC3, method = &quot;stack&quot;, pch = 20, col = c(&quot;gray32&quot;, &quot;gray95&quot;, &quot;seashell3&quot;), main = &quot;Ages of Passenegers on the Titanic&quot;, xlab = &quot;Age&quot;, ylab = &quot;Class&quot;) 2.3 Histograms Histograms are a useful tool for graphically presenting quantitative data. They look similar to barplots (for qualitative data), however the width of the \"bins\" (or bars) can be changed in a histogram. This means that you can choose to include more or fewer observations in each bin shown on the plot. The function to create a histogram in R is hist(). This function takes the following arguments: x =: this is the vector of numeric values that should be used to create the histogram. breaks =: this is vector giving the breakpoints that should be used to create the intervals each bar of the histogram represents, or it can be a single value specifying the number of bins that should be in the histogram. freq =: this takes the values TRUE or FALSE which indicate whether a frequency histogram (TRUE) or a density histogram (FALSE) should be created. By default, a frequency histogram will be created. right =: this takes the values TRUE and FALSE which indicate whether the intervals used to create the bins should be right-closed (TRUE) e.g. \\((x_1, x_2]\\), or left-closed (FALSE) e.g. \\([x_1, x_2)\\). By default the intervals will be right-closed. include.lowest =: this takes the values TRUE or FALSE which indicates whether the lowest value in the data should be included in the first bin, when right-closed intervals are used. The only argument that needs to be provided to the hist() function is x =. We can create a histogram showing the weight of patients from the EPIDURAL data set using the following code. This code creates a vector using the seq() function to provide to the breaks = argument. This vector is \\(\\begin{bmatrix}40&amp;50&amp;60&amp;\\dots&amp;180 \\end{bmatrix}^\\intercal\\), so the histogram has a bin including all observations between 40kg and 50kg, between 50kg and 60kg and so on. Because we have left out the right = argument, these intervals are right-closed. This means they are of the form (40, 50], (50, 60], ..., (170, 180]. The freq = argument has also been left out of this code, so a frequency histogram is created by default. In this case, the height of a bar represents the number of patients that fall into that particular interval. hist(x = EPIDURAL$kg, breaks = seq(from = 40, to = 180, by = 10), col = &quot;coral1&quot;, main = &quot;Patient Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;) If we add in the argument freq = FALSE a density histogram is created instead. The shape of the histogram is identical to the frequency histogram, however the scale on the y-axis has changed. Now, the height of each bar represents the proportion of the patients that fall into that particular interval. hist(x = EPIDURAL$kg, breaks = seq(from = 40, to = 180, by = 10), freq = FALSE, col = &quot;coral1&quot;, main = &quot;Patient Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;) We can instead provide a single value to the breaks = argument. Most of the time, this defines the number of bins that should be used in the histogram, however sometimes the plot created will have a slightly different number from what you specify. This is because R uses \"pretty values\", which essentially means a number of bins will be selected for you, to best produce a sensible looking histogram. For example, when we specify breaks = 4, there are 4 bars in the histogram produced. This is because it makes sense to split the range of our data into the four sets (0, 50], (50, 100], (100, 150] and (150, 200]. hist(x = EPIDURAL$kg, breaks = 4, col = &quot;coral1&quot;, main = &quot;Patient Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;) If we instead specify that breaks = 5, note that the histogram produced actually has 7 intervals. This is because the \"pretty values\" used means that R tries to split the range of our data into at least 5 intervals of the same size, where the upper and lower limit of each interval is an integer. In this case, the intervals used are (40, 60], (60, 80], (80, 100], ..., (160, 180]. It is always a good idea to produce histograms where different intervals have been used to construct the bins to get a proper sense for the shape of the data. hist(x = EPIDURAL$kg, breaks = 5, col = &quot;coral1&quot;, main = &quot;Patient Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;) What single value would you provide to the breaks = argument to create the density histogram of passenger ages on the Titanic shown below? hist(x = TITANIC$age, breaks =, freq = FALSE, main = &quot;Ages of Passengers on the Titanic&quot;, xlab = &quot;Age&quot;) If you instead wanted to provide the argument breaks = with a sequence generated using the seq() function, how would you do this? hist(x = TITANIC$age, breaks = seq(), freq = FALSE, main = &quot;Ages of Passengers on the Titanic&quot;, xlab = &quot;Age&quot;) Solution Both chunks of code below will produce the same histogram shown above. hist(x = TITANIC3$age, breaks = 8, freq = FALSE, main = &quot;Ages of Passengers on the Titanic&quot;, xlab = &quot;Age&quot;) hist(x = TITANIC3$age, breaks = seq(from = 0, to = 80, by = 10), freq = FALSE, main = &quot;Ages of Passengers on the Titanic&quot;, xlab = &quot;Age&quot;) There are several different ways that the breaks used to construct the intervals for a histogram can be constructed. You can read more about these methods in Section 2.4.3.1 Histograms from Probability and Statistics with R. 2.4 Kernel Density Estimators Since the shape of histograms can change so drastically based on the intervals defined, they can sometimes be misleading when trying to determine the shape of data. Kernel density estimators offer a more reliable indication of the shape of data. The function to create a kernel density estimator in R is density(x). The only argument needed for this function is: x =: this is the vector of data for which the kernel density estimate should be computed. This creates a list which can be used to show the kernel density estimate in a plot. In order to superimpose the estimate over the histogram of the data, we can use the lines() function. For example, the following code creates the histogram of the patients' weights, and then superimposes the kernel density estimate dens on top. hist(x = EPIDURAL$kg, breaks = seq(from = 40, to = 180, by = 10), freq = FALSE, col = &quot;grey90&quot;, main = &quot;Patient Weights from the EPIDURAL data set&quot;, xlab = &quot;Weight (kg)&quot;) dens &lt;- density(x = EPIDURAL$kg) lines(dens, col = &quot;coral1&quot;, lwd = 2) We can again clearly see that the distribution of all patients' weights is right skewed and that the mode is around 85kg. In order to use lines() to superimpose the kernel density estimate, the histogram created must be a density histogram. It is also necessary to create a plot first because the lines() function only builds on top of a pre-existing plot. Within the lines() function, the additional arguments col = and lwd = have been included to set the colour and line width respectively of the kernel density estimate. In order to show a kernel density estimate in its own plot, we can use the function plot(). The following code can be used to show the same kernel density estimate as above, but this time without the histogram beneath it. plot(dens, col = &quot;coral1&quot;, lwd = 2, main = &quot;Density of Patient Weights&quot;) Create a plot only showing the kernel density estimate for distribution of passenger ages on the Titanic. Solution age_dens &lt;- density(x = TITANIC3$age, na.rm = TRUE) plot(age_dens, col = &quot;gray32&quot;, lwd = 2, main = &quot;Density of Passeneger Ages&quot;) To read more on how kernel density estimates are constructed, see Section 2.4.3.2 Kernel Density Estimators in Probability and Statistics with R. "],["comp.html", "3 Comparing Samples 3.1 QQ Plots", " 3 Comparing Samples In statistical analysis it is common to want to compare two samples from different groups or \"populations\". When comparing two different groups of data, we might want to answer questions about the properties of the data such as are the centers the same? Are the spreads similar? Do the shapes of the distributions look the same? In order to answer these questions, graphical methods of presenting the data can be useful such as histograms or density plots. For example, we might wish to compare the distribution of the BMI of patients who are given the epidural anesthetic in the traditional sitting position with the distribution of the BMI of patients in the hamstring stretch group. In order to do this, we first need to calculate the BMI of all patients in the EPIDURAL data set, since BMI is not one of the variables measured. EPIDURAL$BMI &lt;- EPIDURAL$kg/(EPIDURAL$cm/100)^2 Then, in order to make it easier to plot the BMI for the two groups separately, we can create two subsets of the data using the subset() function. The first, BMI_sitting, contains the BMI values for the patients that were given the epidural anesthetic in the traditional sitting position. BMI_hamstring similarly stores BMI values, but for the patients given the anesthetic in the hamstring stretch position. BMI_sitting &lt;- subset(x = EPIDURAL, subset = (treatment == &quot;Traditional Sitting&quot;), select = BMI) BMI_hamstring &lt;- subset(x = EPIDURAL, subset = (treatment == &quot;Hamstring Stretch&quot;), select = BMI) Finally, we want to actually view the shape of the distributions for the two groups to see if they are similar. We can do this using two separate histograms of BMI. It doesn't make any sense to compare histograms when the bin widths or the units used on the axes are different, so the following code ensures that, for both histograms, the width of each bin is 5 units, the x-axes range from 20 to 60 and the y-axes range from 0 to 17. The line of code par(mfrow = c(1, 2)) is used to view the histograms side by side. This means that plots will be created in a \\(1\\times 2\\) grid, so two plots can be seen together. par(mfrow = c(1, 1)) sets this back to only one plot being shown at a time. par(mfrow = c(1, 2)) hist(x = BMI_sitting$BMI, breaks = seq(from = 20, to = 60, by = 5), col = &quot;burlywood&quot;, ylim = c(0, 17), main = &quot;Traditional Sitting Group&quot;, xlab = &quot;BMI&quot;, ylab = &quot;Frequency&quot;) hist(x = BMI_hamstring$BMI, breaks = seq(from = 20, to = 60, by = 5), col = &quot;burlywood4&quot;, ylim = c(0, 17), main = &quot;Hamstring Stretch Group&quot;, xlab = &quot;BMI&quot;, ylab = &quot;Frequency&quot;) par(mfrow = c(1, 1)) How would you compare the two distributions shown in the histograms above? Both distributions are skewed to the left. Both distributions are skewed to the right. The distribution for the traditional sitting group is more extremely skewed than the distribution for the hamstring stretch group. The distribution for the hamstring stretch group is more extremely skewed than the distribution for the traditional sitting group. The distribution for the traditional sitting group is symmetric whereas the distribution for the hamstring stretch group is skewed. Rather than histograms, we may wish to compare the distributions of BMI in these two groups using kernel density estimates. The following code plots the kernel density estimate of the BMI for the traditional sitting group against the estimate of the distribution for the BMI of the hamstring stretch group. plot(density(x = BMI_sitting$BMI), col = &quot;burlywood&quot;, lwd = 2, xlim = c(20, 60), main = &quot;Kernel Density Estimates of BMI&quot;, xlab = &quot;BMI&quot;) lines(density(x = BMI_hamstring$BMI), col = &quot;burlywood4&quot;, lwd = 2) Again we can see that both distributions are right-skewed, but that the skew for the hamstring stretch group is slightly more extreme. 3.1 QQ Plots A useful plot for assessing whether data is normally distributed is a normal quantile-quantile (QQ) plot. This uses the quantiles of the standard normal distribution as the \\(x\\) co-ordinates and the quantiles from the data as the \\(y\\) co-ordinates. If the data of interest follows a normal distribution, then we would expect to see the points lying roughly along a straight line. Normal QQ plots can be created in R using the function qqnorm(). The only argument this function needs is y = which gives the vector of data we want to check is normally distributed or not. We can add a straight line to an existing normal QQ plot using the function qqline(), which also takes the same vector of data in the argument y =. The code below creates side-by-side normal QQ plots comparing the distributions of BMI in the group of patients given the epidural anesthetic in the traditional sitting position and in the hamstring stretch position with a standard normal distribution. par(mfrow = c(1, 2)) qqnorm(y = BMI_sitting$BMI) qqline(y = BMI_sitting$BMI) qqnorm(y = BMI_hamstring$BMI) qqline(y = BMI_hamstring$BMI) par(mfrow = c(1, 1)) We can see in both of these QQ plots that the majority of points roughly follow the plotted straight line. For both groups, the higher quantiles in the distribution of BMI start to stray away from this straight line. This is because both these distributions are right-skewed, suggesting they do not follow a normal distribution. We can again see that the distribution for the hamstring stretch group (the right-hand plot) is more extremely right-skewed than that for the traditional sitting group. This is shown in these plots because the large quantiles stray further from the straight line in the hamstring stretch group than in the traditional sitting group. Create a new subset of the TITANIC3 data frame that contains the ages of all passengers who survived the sinking. Plot the quantiles of the distribution of age against the quantiles of a standard normal distribution in a QQ plot. Solution age_survived &lt;- subset(x = TITANIC3, subset = (survived == &quot;Yes&quot;), select = age) qqnorm(y = age_survived$age) qqline(y = age_survived$age) Do you think that the ages of passengers who survived the sinking of the Titanic follow a normal distribution? YesNoCan't say You can read more about how normal QQ plots are constructed in Section 4.3.7 Normal (Gaussian) Distribution in Probability and Statistics with R (specifically pages 301-306). "],["ggplot2.html", "4 ggplot2 4.1 Barplots 4.2 Histograms 4.3 Kernel Density Estimators", " 4 ggplot2 In Sections 1, 2 and 3, the functions used to create the plots and graphs we have seen so far exist in \"base R\". This means that the functions, such as barplot(), hist() and density(), can just be used without having to first load any specific packages. One useful package that can be used to create plots and graphs is called ggplot2 (the \"gg\" stands for \"grammar of graphics\"). As the developers put it: You provide the data, tell ggplot2 how to map variables to aesthetics, what graphical primitives to use, and it takes care of the details. In order to use ggplot2, you must make sure it is first installed on your device and then load it into your RStudio session. install.packages(&quot;ggplot2&quot;) library(ggplot2) Graphs made using ggplot2 are done so in layers (different lines of code). Data is mapped to a geometric object (this tells R what type of plot to construct) and the variables are mapped to different aspects of the plot through an aesthetic function (this states, for example, which variables should be used for the x-axis and which for the y-axis). Other visual elements of the plot can be altered with additional layers. The basic setup of a ggplot2 graph starts with the function ggplot(). The argument that this function takes is: data =: this is a data frame which contains the data to be used in the plot. Additional layers can be added after the ggplot() function using the + operator. For example, the standard setup for a graph using ggplot2 would be as follows in the code below. ggplot(data = dataframe) + geom_object(aes()) Here, you would replace dataframe with the name of the data frame you want to use. The layer geom_object() would also be replaced with the function for the geometric object you want to use. The aes() function is where you can specify what variables you want to include in your plot. Some of the geometric objects you can use with ggplot2, as well as their associated options for within the aesthetic function, aes(), are listed in Table 4.1. Table 4.1: Geometric objects for different graph types and the aesthetic options each can take. Geometric Object Description Aesthetic Options geom_bar() Barplot x =: the variable to be plotted along the x-axis. fill =: the categorical variable to be used to split up the bars, or create separate side-by-side bars. geom_histogram() Histogram x =: the variable to be plotted along the x-axis. fill =: the categorical variable to be used to fill the bars a different colour for each level of the variable. geom_density() Density Estimate x =: the variable to be plotted along the x-axis. fill =: a categorical variable for which each level will be given a different colour under the density curve. linetype =: a categorical variable for which each level will be given a different line style. 4.1 Barplots Let's make our first graph using ggplot2. We can recreate the barplot showing the number of patients from the EPIDURAL data set that fall into the three categories indicating how easy it was to find where to administer the epidural anesthetic, seen in Section 1.2. To create the basic barplot, we only need to provide the arguments data = EPIDURAL within the ggplot() function. We want to use the geometric object function geom_bar() to create a barplot and provide x = ease within the aes() function which maps the levels of ease to the x-axis. ggplot(data = EPIDURAL) + geom_bar(aes(x = ease)) This creates a very simplistic barplot, where the bars are labelled with each level of the variable ease and are coloured grey. ggplot2 uses a default \"theme\" which colours the background grey and includes grid lines in white. We can add titles and axes labels to ggplot2 graphs in an additional layer using the function labs(). This takes the arguments title =, x = and y = as shown in the code below. ggplot(data = EPIDURAL) + geom_bar(aes(x = ease)) + labs(title = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;, x = &quot;Ease&quot;, y = &quot;Frequency&quot;) We were also able to produce barplots in base R where the height of each bar was split based on the levels of a categorical variable (for example, splitting by the different physicians in Section 1.5). We can do the same using ggplot2 by including the aesthetic argument fill = doctor in the aes() function. This means that we want to \"fill\" each bar to show how many of the patients in each level of ease were seen by each physician. ggplot(data = EPIDURAL) + geom_bar(aes(x = ease, fill = doctor)) + labs(title = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;, x = &quot;Ease&quot;, y = &quot;Frequency&quot;) Note that the colours used by ggplot2 are chosen automatically. A different one is assigned to each doctor because we have used the argument fill = doctor. A legend is also included in the plot automatically, showing which colour corresponds to which doctor. The title \"doctor\" is used for the legend since this is the variable name. To change the title of the legend, we need to include another layer in the code with the function guides(). We can specify the title using guide_legend(\"Title\") as shown in the code below. This is passed to the argument fill = because \"doctor\" has been passed to the same fill = argument within the aes() function in geom_bar(). By default, barplots showing bivariate data are \"stacked\" in ggplot2. If we wanted to create separate bars for each doctor within the different levels of ease, then we need to include the argument position = \"dodge\" within the geom_bar() function. Note that this is outside the aes() function, as shown in the code below. ggplot(data = EPIDURAL) + geom_bar(aes(x = ease, fill = doctor), position = &quot;dodge&quot;) + labs(title = &quot;Ease of Locating Anesthesia Administering Location in Patients&quot;, x = &quot;Ease&quot;, y = &quot;Frequency&quot;) + guides(fill = guide_legend(&quot;Physician&quot;)) Complete the code below to create the barplot shown below, showing the number of passengers who survived and did not survive in each class from the TITANIC3 data set. ggplot(data = TITANIC) + geom_bar(aes(x =, fill =, position =) + labs(title = &quot;Passengers Surviving the Titanic Sinking in each Class&quot;, x = &quot;Class&quot;, y = &quot;Frequency&quot;) + guides(= guide_legend(\"Did the passenger survive?\")) Solution ggplot(data = TITANIC3) + geom_bar(aes(x = pclass, fill = survived), position = &quot;dodge&quot;) + labs(title = &quot;Passengers Surviving the Titanic Sinking in each Class&quot;, x = &quot;Class&quot;, y = &quot;Frequency&quot;) + guides(fill = guide_legend(&quot;Did the passenger survive?&quot;)) 4.2 Histograms Histograms are easy to make in ggplot2 using the function geom_histogram(). It is possible to specify the binwidth used to create the bars by including the argument binwidth = within this function (but outside the aes() function). The code below creates a histogram showing the weights of all patients in the EPIDURAL data set. The binwidth has been set so that each bar has a range of 10kg. ggplot(data = EPIDURAL) + geom_histogram(aes(x = kg), binwidth = 10) + labs(title = &quot;Patient Weights from the EPIDURAL data set&quot;, x = &quot;Weight (kg)&quot;, y = &quot;Frequency&quot;) We can change the binwidth = argument so that the interval each bar covers is increased or decreased. In the code below, we have changed the argument to binwidth = 50 so each bar covers a range of 50kg, resulting in fewer and wider bars. ggplot(data = EPIDURAL) + geom_histogram(aes(x = kg), binwidth = 50) + labs(title = &quot;Patient Weights from the EPIDURAL data set&quot;, x = &quot;Weight (kg)&quot;, y = &quot;Density&quot;) Create a histogram, using ggplot2, showing the ages of all passengers on the Titanic. Label your plot appropriately and consider using different binwidths to explore the shape of the distribution. Solution ggplot(data = TITANIC3) + geom_histogram(aes(x = age), binwidth = 10) + labs(title = &quot;Ages of Passengers on the Titanic&quot;, x = &quot;Age&quot;, y = &quot;Frequency&quot;) 4.3 Kernel Density Estimators To create plots of kernel density estimates in ggplot2, we use the function geom_density(). A simple plot showing the kernel density estimate of the weights of all patients from the EPIDURAL data set is created using the code below. ggplot(data = EPIDURAL) + geom_density(aes(x = kg)) + labs(title = &quot;Density of Patient Weights&quot;, x = &quot;Weight (kg)&quot;, y = &quot;Density&quot;) We are able to superimpose a density estimate above a histogram by creating the histogram and density curve as two separate layers after the ggplot() function. For example, in the code below the histogram is created first and then the density plot is built on top of it. Remember that the histogram needs to be a density histogram, and not a frequency histogram, in order to be able to superimpose a density curve. We can create a density histogram in ggplot2 by including the argument y = after_stat(density) within the aes() function in geom_histogram(). ggplot(data = EPIDURAL) + geom_histogram(aes(x = kg, y = after_stat(density)), binwidth = 10) + geom_density(aes(x = kg)) + labs(title = &quot;Density of Patient Weights&quot;, x = &quot;Weight (kg)&quot;, y = &quot;Density&quot;) Section 3 looked at comparing the distributions of BMI values for patients in the two treatment groups (traditional sitting and hamstring stretch). We can use ggplot2 to create side-by-side plots showing a histogram and kernel density estimate of these distributions for the two groups. In order to create a plot for each treatment group, we need to use the function facet_grid(). This splits the plots made across different rows and/or columns. We need to include the names of categorical variables in the style of a formula using the ~ operator. The levels of the variable to the left of ~ will make up the rows, and if a variable is included to the right of ~ then the levels of this will make up the columns that the plots are split across. Using the formula . ~ treatment means we have one column for the traditional sitting group and another for the hamstring stretch group. In the code below we have coloured the histogram a different colour for each group using the argument fill = treatment within the aes() argument in geom_histogram(). This automatically creates a legend showing which colour is for which group, but because the columns of the plot are already labelled, this legend is unnecessary. We can remove the legend by including fill = \"none\" within the guides() argument. ggplot(data = EPIDURAL) + geom_histogram(aes(x = BMI, y = after_stat(density), fill = treatment), binwidth = 5) + geom_density(aes(x = BMI)) + facet_grid(. ~ treatment) + labs(title = &quot;Density of Patients&#39; BMI&quot;, x = &quot;Weight (kg)&quot;, y = &quot;Density&quot;) + guides(fill = &quot;none&quot;) We can see from the plots above that both distributions are right skewed, however the skew in the hamstring stretch group is slightly more extreme. Complete the code below to create the following histogram and density plots which show the distribution of passenger age for each class of passengers on board the Titanic. ggplot(data = TITANIC3) + geom_histogram(aes(x = age, y =, fill =), binwidth = 5) + geom_density(aes(x = age)) + facet_grid() + labs(title = &quot;Density of Passenger Ages&quot;, x = &quot;Age&quot;, y = &quot;Density&quot;) + guides(fill = &quot;none&quot;) Solution ggplot(data = TITANIC3) + geom_histogram(aes(x = age, y = after_stat(density), fill = pclass), binwidth = 5) + geom_density(aes(x = age)) + facet_grid(pclass ~ .) + labs(title = &quot;Density of Passenger Ages&quot;, x = &quot;Age&quot;, y = &quot;Density&quot;) + guides(fill = &quot;none&quot;) "],["further-exercises.html", "5 Further Exercises Exercise 1 Exercise 2", " 5 Further Exercises Exercise 1 The data set VIT2005 from the PASWR2 package stores information relating to 218 different apartments in Vitoria, Spain. For a full list of the variables included and the information they represent, use the code help(VIT2005). You can load VIT2005 into your Environment tab using the following code. library(PASWR2) data(&quot;VIT2005&quot;) The variable \"out\" details how much of an apartment is exposed to the elements. It has levels \"E25\", \"E50\", \"E75\" and \"E100\" corresponding to 25%, 50%, 75% and 100% exposure respectively. Create a frequency table, a pie chart and a barplot in base R which show the number of apartments from VIT2005 within each category of the \"out\" variable. You may wish to relabel and reorder the categories of \"out\" first of all. The variable \"area\" is a numeric variable detailing the size (in square metres) of each apartment. Create a new categorical variable, called \"size\", indicating whether an apartment is considered \"Small\", \"Medium\" or \"Large\". Apartments smaller than 100m2 should be labelled as small, those between 100m2 and 150m2 should be labelled as medium and any apartments larger than 150m2 should be labelled as large. The function cut() will be useful for this. Using this new categorical variable, create a barplot in base R to investigate whether the proportion of apartments in each level of exposure is different for small, medium and large apartments. Make sure that apartment size is placed along the x-axis, there is a different bar for each level of exposure and that the y-axis shows proportion, not frequency. \"totalprice\" gives the market price (in Euros) for each apartment. Create a histogram in base R showing the shape of the distribution of apartment prices. Superimpose a kernel density estimate of the distribution on the histogram. Investigate whether the distribution of apartment price is normal using a QQ plot. Do you think this is a normal distribution? Use three histograms to compare the distributions of apartment prices for small, medium and large apartments. Make sure you are using the same breaks = and range along the y-axes in all plots so that the distributions can be easily compared. What differences are there between these distributions? Remember to subset the data first so that the first plot is only for prices of small apartments etc. Exercise 2 The file \"babies.csv\" contains data on the birth weight of babies born to different mothers and whether each mother currently smokes or does not smoke (a full list of the variables included in this data set can be found here). Download the data from Moodle and load the data set into your Enivronment tab using the code below and use babies to recreate the following two plots using ggplot2. babies &lt;- read.csv(file = &quot;babies.csv&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
