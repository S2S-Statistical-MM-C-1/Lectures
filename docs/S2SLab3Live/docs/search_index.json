[["index.html", "S2S Lab 3 1 Welcome!", " S2S Lab 3 1 Welcome! Welcome to the third S2S lab. This lab builds on what we already know about data frames and will teach you how to save data files of different types in RStudio and then manipulate them in several ways, such as creating new variables, working with a subset of a larger data frame or merging together data from different sources. Working with data is a key skill throughout statistics and it will often be saved as a data frame, so it is important to know all the things that can be done with them. This lab will also introduce you to some fundamental concepts of coding, in particular using R to access information about statistical distributions, writing repeating code using if statements and for loops, and teach you how to define your own functions. "],["reading.html", "2 Reading in Data 2.1 Setting your working directory 2.2 read.table() 2.3 read.csv()", " 2 Reading in Data In Lab 2, we saw how to read data frames into our Environment tab from a pre-installed and loaded R package. In reality, the data you are using won't always come from an R package and will likely be stored elsewhere. In this lab we will learn how to read data into R from different locations. 2.1 Setting your working directory Before we can start reading in any data sets, we need to know about working directories in R. This is essentially a folder where you will save any data sets or R files that you tell R to automatically look within whenever you want to read in any data. From now on, we recommend that you create a folder for each S2S lab on your own device, where you can save the R script of code you write, as well as any files containing data that you use in the lab. For example, create a folder called \"S2S Lab 3\" for this lab, somewhere where you can find it again (if you are using a lab PC, then save these folders in your M: Drive - this ensures you can access them again from any PC across the university). Now you can download the data files on Moodle and save them in this folder (make sure to keep them named as they are). Once you have a folder created, you can tell R to automatically look within that folder whenever you want to open or load in specific files. To do this, within RStudio, click on: 'Session' in the menu bar along the top of the RStudio window 'Set Working Directory' 'Choose Directory...' This will open a pop-up window where you can navigate to the folder you just created for this lab. Select this folder and click 'Open' to set the working directory. Now the data sets that are saved in the folder you set as the working directory will appear in the Files tab in RStudio. Any other files saved in this folder will also appear here. To learn more about how to set a working directory within RStudio, refer to Section 1.7 RStudio of Probability and Statistics with R. 2.2 read.table() A common format for data to be saved in is something called 'table format'. These are files with the extension '.txt'. We use the function read.table() to read these file types into R. read.table() takes (amongst others) the following arguments: file =: this is the location of the '.txt' file you wish to read in. If you have set the working directory to where this file is stored, you only need to include the full name of the file in quotation marks, \" \". header =: this takes the values TRUE or FALSE which indicate whether the original '.txt' file contains column names as its first row. By default, this is set to FALSE, so column names will not be included. sep =: this shows the 'field separator character' which shows how each element in the '.txt' file are separated. Common values for this argument include \"\" if elements are separated by spaces, or \"\\t\" if elements are separated by tab spaces. By default, this is set to \"\". na.strings =: this shows the characters which are used to denote missing values in the '.txt' file. By default this takes the value NA, but other ways missing values could be shown in the file might include \"?\", \".\" or \"*\" for example. dec =: this is the character used in the '.txt' file to denote a decimal point. It is most common that this will be \".\", and this is the default value, however some files may use a comma, \",\" as a decimal point so watch out for this! The only necessary argument in read.table() is file =, however it is always worth checking the format of the original '.txt' file so that you read it into R correctly. For example, \"chol.txt\" is shown in Figure 2.1. This is a data set from an observational experiment measuring the cholesterol levels of patients and their smoking status. The variables included are: \"id\": a unique code identifying each patient in the experiment. \"ldl\": a measure of each patient's low-density lipoprotein (LDL) cholesterol level. \"hdl\": a measure of each patient's high-density lipoprotein (HDL) cholesterol level. \"trig\": a measure of the triglycerides levels in each patient's blood. \"age\": the patient's age in years. \"gender\": the patient's gender (female or male). \"smoke\": whether a patient is a current-smoker, ex-smoker, or non-smoker. We can see in Figure 2.1 that \"chol.txt\" does include column names (i.e header = TRUE) and that each element of the data set is separated with a space (i.e. sep = \"\"). The missing values in \"chol.txt\" are already represented by NA (i.e. the symbol for missing values in R), so we don't need to include na.strings =. Figure 2.1: Screenshot of chol.txt file In order to read the file chol.txt into R we can use the following code. chol &lt;- read.table(file = &quot;chol.txt&quot;, header = TRUE) Note that we have left out sep = \"\" because this is the default value of the argument so it is not required to type it in the function read.table(). It is good practise to compare the object you've just saved in the Environment tab with the contents of the original data file to make sure everything is as you expect. This will highlight any discrepancies and allow you to check whether additional arguments are required to fix them e.g. na.strings = or header =. 2.3 read.csv() Another common file type that data may be stored in are '.csv' files. If data has been input into Microsoft Excel, it will often be exported as a '.csv' file, so we see these a lot. In order to read '.csv' files into R, we use the function read.csv(). This takes very similar arguments to read.table(), including: file =: this is the full name of the '.csv' file in quotation marks, provided it is saved in the folder you have set as your working directory. header =: by default this takes the value TRUE, so column names are automatically included for '.csv' files. sep =: the default separator character is sep = \",\". na.strings =: the default for denoting missing values in the original '.csv' file is set to \"NA\". dec =: the default decimal point is set to \".\". Again, the only necessary argument in read.csv() is file =. Read the file \"edu.csv\" into R and save it as a data frame called education. This is a data set containing information on the total numbers of pupils and teachers in schools of different education levels in Scotland. The variables included are: \"year\": the year measurements were taken in (2016-2022). \"level\": the level of education measurements were taken from (\"ELC\", \"Primary\" or \"Secondary\"). \"schools\": the total number of schools across Scotland in the given year/level combination. \"teachers\": the total number of teachers employed in all the schools in the given year/level combination. \"pupils\": the total number of pupils attending all the schools in the given year/level combination. The use of the functions read.table() and read.csv() is detailed in Section 1.10.1 Using read.table() of Probability and Statistics with R. There are several other file types that data can be stored in, and numerous ways to read data sets into R. If you are curious about other ways to do this, refer to 1.10 Reading and Saving Data in R in Probability and Statistics with R. "],["data.html", "3 Working With Data 3.1 Checking variable types 3.2 Dealing with NA values 3.3 Sorting data frames 3.4 Subsetting 3.5 Summarising data 3.6 Creating variables 3.7 Merging data frames", " 3 Working With Data 3.1 Checking variable types Once a data frame has been read into R, it is always a good idea to examine its contents using the str() function to see the structure of the data object. We have already seen the str() function in Lab 2 but as a reminder, it shows us the type of vector each column in a data frame is saved as. Running the following code tells us that the four variables ldl, hdl, trig and age are all integer vectors and that id, gender and smoke are character vectors. str(chol) &#39;data.frame&#39;: 13 obs. of 7 variables: $ id : chr &quot;P912&quot; &quot;P215&quot; &quot;P063&quot; &quot;P117&quot; ... $ ldl : int 175 196 139 162 140 147 82 165 149 95 ... $ hdl : int 25 36 65 37 117 51 81 63 49 54 ... $ trig : int 148 92 NA 139 59 126 NA 120 NA 157 ... $ age : int 39 32 42 30 42 65 57 48 32 55 ... $ gender: chr &quot;female&quot; &quot;female&quot; &quot;male&quot; &quot;female&quot; ... $ smoke : chr &quot;no&quot; &quot;no&quot; NA &quot;ex-smoker&quot; ... Because gender only takes the values \"female\" or \"male\" in this case, and smoke is categorised into three levels, \"no\", \"ex-smoker\" and \"current\", it makes sense to treat both these variables as factors instead of character vectors. We can use what we learned in Lab 2 to change these variables into factors. chol$gender &lt;- factor(x = chol$gender, levels = c(&quot;female&quot;, &quot;male&quot;)) chol$smoke &lt;- factor(x = chol$smoke, levels = c(&quot;no&quot;, &quot;ex-smoker&quot;, &quot;current&quot;)) Now using str() to check the type of vector each column is saved as shows us that gender and smoke are both now factors. str(chol) &#39;data.frame&#39;: 13 obs. of 7 variables: $ id : chr &quot;P912&quot; &quot;P215&quot; &quot;P063&quot; &quot;P117&quot; ... $ ldl : int 175 196 139 162 140 147 82 165 149 95 ... $ hdl : int 25 36 65 37 117 51 81 63 49 54 ... $ trig : int 148 92 NA 139 59 126 NA 120 NA 157 ... $ age : int 39 32 42 30 42 65 57 48 32 55 ... $ gender: Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 1 1 2 1 1 1 2 2 1 1 ... $ smoke : Factor w/ 3 levels &quot;no&quot;,&quot;ex-smoker&quot;,..: 1 1 NA 2 2 2 1 3 1 2 ... What type of variable is schools saved as in the education data frame? Write some code to change the variables year and level in education to be factor variables. Refer to Section 1.11 Working with Data of Probability and Statistics with R to learn more about checking the setup of a data set. 3.2 Dealing with NA values Data sets will often have missing values for a variety of different reasons; maybe because of human error, maybe because information was not disclosed or maybe because of a failed experiment for example. When data is correctly read into R these unknown values will be denoted by NA. In order to conduct analysis or perform calculations on your data, you may wish to remove these missing values from your data set. Always think about whether this is an appropriate thing to do. One way in which we can remove missing values from a data set is to use the function na.omit(). This will return the data frame with any 'incomplete cases' removed. That is, any rows that have NA as the value for any variable will be removed from the data frame. Looking at chol, we can see that there are missing values in rows 3, 7 and 9. id ldl hdl trig age gender smoke 1 P912 175 25 148 39 female no 2 P215 196 36 92 32 female no 3 P063 139 65 NA 42 male NA 4 P117 162 37 139 30 female ex-smoker 5 P613 140 117 59 42 female ex-smoker 6 P332 147 51 126 65 female ex-smoker 7 P951 82 81 NA 57 male no 8 P004 165 63 120 48 male current 9 P725 149 49 NA 32 female no 10 P901 95 54 157 55 female ex-smoker 11 P103 169 59 67 48 female no 12 P843 174 117 168 41 female no 13 P753 91 52 146 69 female current If we run the following code, then these rows are removed from the data frame and we are left with only the 'complete cases'. na.omit(chol) id ldl hdl trig age gender smoke 1 P912 175 25 148 39 female no 2 P215 196 36 92 32 female no 4 P117 162 37 139 30 female ex-smoker 5 P613 140 117 59 42 female ex-smoker 6 P332 147 51 126 65 female ex-smoker 8 P004 165 63 120 48 male current 10 P901 95 54 157 55 female ex-smoker 11 P103 169 59 67 48 female no 12 P843 174 117 168 41 female no 13 P753 91 52 146 69 female current Note that na.omit() preserves the original row labels. This means that there are no rows labelled 3, 7 or 9 in the resulting data frame because they have been completely removed. complete.cases() is another useful function that can be used to remove rows that have NA values. This returns a logical vector, the same length as the number of rows of the data frame, that indicates whether a row contains any NA values (FALSE), or whether it is 'complete' (TRUE). complete.cases(chol) [1] TRUE TRUE FALSE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE [13] TRUE Again we can see that the rows with missing values in chol are rows 3, 7 and 9 (since the third, seventh and ninth values in the output above are all FALSE). We can then use this logical vector to extract the rows which are complete from chol. chol[complete.cases(chol), ] id ldl hdl trig age gender smoke 1 P912 175 25 148 39 female no 2 P215 196 36 92 32 female no 4 P117 162 37 139 30 female ex-smoker 5 P613 140 117 59 42 female ex-smoker 6 P332 147 51 126 65 female ex-smoker 8 P004 165 63 120 48 male current 10 P901 95 54 157 55 female ex-smoker 11 P103 169 59 67 48 female no 12 P843 174 117 168 41 female no 13 P753 91 52 146 69 female current Here, using na.omit() and complete.cases() have returned the same output. Which rows in education have missing values? Write code to remove all rows in education which contain NA values. In the case where we only want to know which entries of a vector or specific variable in a data frame are NA, we can use the function is.na(). For example, if missing values in the trig variable were not of concern but we wanted to identify missing values in the smoke column, we could use the following code. is.na(chol$smoke) [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE We can see that only the third row has the value NA for smoke, since the third element in the output from is.na() above is TRUE. In order to remove the row where smoke has a missing value, we can use the following code to index the chol data frame. chol[!is.na(chol$smoke), ] id ldl hdl trig age gender smoke 1 P912 175 25 148 39 female no 2 P215 196 36 92 32 female no 4 P117 162 37 139 30 female ex-smoker 5 P613 140 117 59 42 female ex-smoker 6 P332 147 51 126 65 female ex-smoker 7 P951 82 81 NA 57 male no 8 P004 165 63 120 48 male current 9 P725 149 49 NA 32 female no 10 P901 95 54 157 55 female ex-smoker 11 P103 169 59 67 48 female no 12 P843 174 117 168 41 female no 13 P753 91 52 146 69 female current Note that we use ! in front of is.na() so that the logical vector returned has the value TRUE when values are complete and FALSE when values are missing i.e. NA. You can look at further examples of dealing with missing data in Section 1.11.1 Dealing with NA Values of Probability and Statistics with R. 3.3 Sorting data frames When investigating your data sets, you may want to order the values of a particular variable in increasing or decreasing order. This is easily done using the sort() function. For example, we can view the ages of all subjects in chol, in increasing order, using the code below. sort(chol$age) [1] 30 32 32 39 41 42 42 48 48 55 57 65 69 Note that if we wanted to view these ages in decreasing order, we would add the argument decreasing = TRUE to the sort() function. What is the largest value for pupils from the education data frame? The downside of using sort() is that we can only see the values from one variable of a data frame. If instead we wanted to order all subjects in chol from the youngest to the oldest and still see the values of all the other variables, we can use the function order(). order() will return a vector showing which row has the smallest value, then the second smallest value and so on. For example, the following code shows us that the fourth subject in chol is the youngest and the thirteenth subject is the eldest. order(chol$age) [1] 4 2 9 1 12 3 5 8 11 10 7 6 13 We can then use this vector to index the full data frame chol and see all the variables for each subject at once. chol[order(chol$age), ] id ldl hdl trig age gender smoke 4 P117 162 37 139 30 female ex-smoker 2 P215 196 36 92 32 female no 9 P725 149 49 NA 32 female no 1 P912 175 25 148 39 female no 12 P843 174 117 168 41 female no 3 P063 139 65 NA 42 male NA 5 P613 140 117 59 42 female ex-smoker 8 P004 165 63 120 48 male current 11 P103 169 59 67 48 female no 10 P901 95 54 157 55 female ex-smoker 7 P951 82 81 NA 57 male no 6 P332 147 51 126 65 female ex-smoker 13 P753 91 52 146 69 female current In the output above, note that there are multiple subjects aged 32, 42 and 48. After ordering by age, R automatically shows these subjects with the same age in order of increasing row number. We could however add a second or third argument to order() to order the rows by another variable in the case where there are repeated values of the first variable. For example, the following code orders all the subjects in chol by age first, and then for any subjects that are the same age, they will then be sorted in order of increasing ldl. chol[order(chol$age, chol$ldl), ] id ldl hdl trig age gender smoke 4 P117 162 37 139 30 female ex-smoker 9 P725 149 49 NA 32 female no 2 P215 196 36 92 32 female no 1 P912 175 25 148 39 female no 12 P843 174 117 168 41 female no 3 P063 139 65 NA 42 male NA 5 P613 140 117 59 42 female ex-smoker 8 P004 165 63 120 48 male current 11 P103 169 59 67 48 female no 10 P901 95 54 157 55 female ex-smoker 7 P951 82 81 NA 57 male no 6 P332 147 51 126 65 female ex-smoker 13 P753 91 52 146 69 female current Write code to sort the observations from education in decreasing order of the number of pupils. Look at Section 1.11.3 Sorting a Data Frame by One or More of Its Columns of Probability and Statistics with R to learn more about sorting and ordering data sets. 3.4 Subsetting When we want to only view particular elements of a data frame, this is known as subsetting the data. This is useful if you're dealing with extremely large data sets and only want to analyse female subjects, or subjects who are all from the same country for example. Subsetting the data means that you would extract only these subjects that you are actually interested in. A useful function for extracting elements of a data frame is the function subset() (which we first saw in Lab 1). This allows us to extract the elements of a data frame which meet particular conditions. The arguments that subset() takes are: x =: this is the data frame that we want to extract particular elements from. subset =: this is a logical statement which determines the elements to keep in the subsetted data frame. select =: this shows the column or columns from the data frame which the logical statement should be applied to. For example, if we wanted to view the subjects in chol who have an LDL of greater than 170, then we can use the following code. subset(x = chol, subset = ldl &gt; 170, select = ldl) ldl 1 175 2 196 12 174 This shows us that there are three patients with LDL greater than 170 (subset = ldl &gt; 170) and we can also see the values of LDL for these patients (select = ldl). If we wanted to see the values of the other variables in the data frame for only those patients with LDL greater than 170, then we can simply leave out the select = argument. subset(x = chol, subset = ldl &gt; 170) id ldl hdl trig age gender smoke 1 P912 175 25 148 39 female no 2 P215 196 36 92 32 female no 12 P843 174 117 168 41 female no Note that it is also possible to subset a data frame using logical statements within square brackets, [ ]. We could return the same output as above by indexing the chol using the following code. chol[chol$ldl &gt; 170, ] id ldl hdl trig age gender smoke 1 P912 175 25 148 39 female no 2 P215 196 36 92 32 female no 12 P843 174 117 168 41 female no Write some code to subset education to show the number of schools that have a collective total of more than 310,000 pupils in the years 2020, 2021 or 2022. You can read more about subsetting data frames in Section 1.12 Using Logical Operators with Data Frames in Probability and Statistics with R. 3.5 Summarising data Data sets will often contain a lot of information which is not easy to interpret at a glance. It is therefore useful to be able to summarise the data they contain, in appropriate ways for each different type of variable. One of the simplest functions to help summarise a data frame is the summary() function. summary(chol) id ldl hdl trig Length:13 Min. : 82.0 Min. : 25 Min. : 59.0 Class :character 1st Qu.:139.0 1st Qu.: 49 1st Qu.: 99.0 Mode :character Median :149.0 Median : 54 Median :132.5 Mean :144.9 Mean : 62 Mean :122.2 3rd Qu.:169.0 3rd Qu.: 65 3rd Qu.:147.5 Max. :196.0 Max. :117 Max. :168.0 NA&#39;s :3 age gender smoke Min. :30.00 female:10 no :6 1st Qu.:39.00 male : 3 ex-smoker:4 Median :42.00 current :2 Mean :46.15 NA&#39;s :1 3rd Qu.:55.00 Max. :69.00 The output from summary() shows information for each column in the data frame you provide as the argument. For numerical variables, we are shown summary statistics such as the minimum value, the mean or the 3rd quartile. For factor variables, we are shown how many observations there are in each level of the factor. If there are any NA values in a column, the total number of these will also be shown for each variable. When a data frame contains categorical variables, a neater way to summarise the counts of the different levels is in contingency tables. These show counts of how many times each level of a categorical variable appeared in the data frame. The function to create contingency tables in R is table(). The only argument that table() needs is the factor variable you want to summarise. For example, we can quickly show counts of how many subjects in chol fall into each of the three levels of the smoke variable using the following code. table(chol$smoke) no ex-smoker current 6 4 2 If we wanted to further split these counts by the variable gender, then we simply add this as a second argument to the table() function. smoke_counts &lt;- table(chol$smoke, chol$gender) smoke_counts female male no 5 1 ex-smoker 4 0 current 1 1 We can easily compute the sums of rows or columns in a table using the function margin.table(). Here we need to provide margin.table() with the following arguments: x =: this is the table you want to sum over. margin =: this tells R whether you want to sum over rows (set the value to 1), or columns (set the value to 2). For example, we can use the table smoke_counts, created above, to count the number of female and male subjects for whom we know their smoking status, using margin.table(). margin.table(x = smoke_counts, margin = 2) female male 10 2 Another useful function to use with tables is prop.table(). This takes the same arguments as margin.table() but shows row or column proportions, rather than sums. For example, to calculate the proportions of current smokers, ex-smokers and non-smokers that are female and male, we can use the following code. prop.table(x = smoke_counts, margin = 1) female male no 0.8333333 0.1666667 ex-smoker 1.0000000 0.0000000 current 0.5000000 0.5000000 Suppose you wanted to calculate summary statistics for one variable in a data frame, but have it split by the levels of a different categorical variable. The function in R which calculates a summary statistic for one numeric variable, split by the levels of a factor is tapply(). The arguments that tapply() can take are as follows: X =: this is the numeric variable that you want to apply the function calculating some summary statistic to. INDEX =: this is a list containing the categorical variable (or variables) you want to split the calculation of the summary statistic across. FUN =: this is the name of the function you want to apply to the numeric variable. Examples include mean, median, max, min, mode, sd etc. In the case where we are interested in knowing the mean HDL for subjects who were current smokers, subjects who were ex-smokers and subjects who were non-smokers, we can use tapply(). tapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean) no ex-smoker current 61.16667 64.75000 57.50000 We can see, for example, that the mean HDL for non-smokers is 61.17. The list provided to the INDEX = argument can contain more than one categorical variable. For example, we can calculate the mean HDL of females and males for each level of the smoke variable using the following code. tapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean) female male no 57.20 81 ex-smoker 64.75 NA current 52.00 63 Now we can see that the mean HDL for females who are non-smokers is 57.20. The mean HDL for males who are ex-smokers is NA because there are no males included in chol who are ex-smokers. What is the mean total number of teachers in primary schools across all years? To read more on creating tables and summarising data in R, see Sections 1.13 Tables and 1.14 Summarizing Functions in Probability and Statistics with R. 3.6 Creating variables In the case where we have another vector or data frame that we wish to join to an existing one, we can do this using one of the functions cbind() or rbind(). cbind() combines the vectors or data frames together by making additional columns, whereas rbind() combines them by adding the new vector or data frame as additional rows. Let's see an example to understand how this works. The file measurements.csv contains information on the heights and weights of all 13 patients in the original chol data frame. We can begin by reading it in to the Environment tab using the following code. measurements &lt;- read.csv(file = &quot;measurements.csv&quot;) We can then add measurements to chol as two additional columns and save the resulting data frame as chol_full using the code below. chol_full &lt;- cbind(chol, measurements) head(chol_full) id ldl hdl trig age gender smoke weight height P912 175 25 148 39 female no 90.77 1.69 P215 196 36 92 32 female no 75.06 1.75 P063 139 65 NA 42 male NA 73.99 1.84 P117 162 37 139 30 female ex-smoker 86.25 1.83 P613 140 117 59 42 female ex-smoker 76.95 1.81 P332 147 51 126 65 female ex-smoker 57.66 1.75 Another way to easily create a new variable in a data frame is to use the $ operator. We can simply add the name of the data frame to the left of $ and our new variable name to the right. Then we can set this variable to be any pre-existing vector, or calculate a new vector based on variables from the data frame. For example, if we wanted to create a new variable, bmi, in chol which shows the BMI of each patient, then we can use the following code. chol_full$bmi &lt;- chol_full$weight/(chol_full$height)^2 head(chol_full) id ldl hdl trig age gender smoke weight height bmi P912 175 25 148 39 female no 90.77 1.69 31.78110 P215 196 36 92 32 female no 75.06 1.75 24.50939 P063 139 65 NA 42 male NA 73.99 1.84 21.85432 P117 162 37 139 30 female ex-smoker 86.25 1.83 25.75473 P613 140 117 59 42 female ex-smoker 76.95 1.81 23.48829 P332 147 51 126 65 female ex-smoker 57.66 1.75 18.82776 In the education data frame, create a new variable called ratio which calculates the pupil to teacher ratio in each level of education. That is, \\[\\mbox{ratio}=\\textstyle\\frac{\\mbox{puils}}{\\mbox{teachers}}\\] Now suppose that information on a fourteenth subject is known but has not been included in the original chol data frame. This data is shown in Table 3.1 below. Table 3.1: Cholesterol data for the fourteenth patient. id ldl hdl trig age gender smoke weight height P461 148 78 120 41 male current 84.05 1.79 In this case we can add the new subject as an additional row using the rbind() function. First, we need to create a data frame containing the information for this subject. In order for us to add this data frame as a row to chol_full, it needs to have the same number of variables. Therefore, we also need to calculate the BMI for this subject and call it bmi. We can do all this with the following code. subject &lt;- data.frame(id = &quot;P461&quot;, ldl = 148, hdl = 78, trig = 120, age = 41, gender = &quot;male&quot;, smoke = &quot;current&quot;, weight = 84.05, height = 1.79) subject$bmi &lt;- subject$weight/(subject$height)^2 Now we can add this subject to chol_full using the code below. chol_full &lt;- rbind(chol_full, subject) tail(chol_full) id ldl hdl trig age gender smoke weight height bmi 9 P725 149 49 NA 32 female no 65.37 1.67 23.43935 10 P901 95 54 157 55 female ex-smoker 80.34 1.62 30.61271 11 P103 169 59 67 48 female no 74.90 1.61 28.89549 12 P843 174 117 168 41 female no 63.78 1.77 20.35813 13 P753 91 52 146 69 female current 71.58 1.62 27.27481 14 P461 148 78 120 41 male current 84.05 1.79 26.23202 Note that tail() is a function very similar to head(), but rather than showing the first 6 rows by default, it shows the last 6. For numeric variables in a data frame, it can sometimes be useful to split the values into intervals and create a new factor with numerical levels. For example, if we wanted to identify high, mid and low levels of hdl in chol_full. The function that can do this in R is cut(). The arguments that cut() takes are: x =: this is the numeric variable that you want to split into different levels. breaks =: this is the number of levels you want to split the numeric vector into. include.lowest =: this takes the values TRUE or FALSE, indicating whether the lowest value in the numeric variable should be included in the first level. By default this is set to FALSE so this smallest value is not included. We can split hdl into three levels using the following code. cut(x = chol_full$hdl, breaks = 3, include.lowest = TRUE) [1] [24.9,55.7] [24.9,55.7] (55.7,86.3] [24.9,55.7] (86.3,117] [24.9,55.7] [7] (55.7,86.3] (55.7,86.3] [24.9,55.7] [24.9,55.7] (55.7,86.3] (86.3,117] [13] [24.9,55.7] (55.7,86.3] Levels: [24.9,55.7] (55.7,86.3] (86.3,117] This tells us that the lowest level is the range [24.9, 55.7], the middle level is (55.7, 86.3] and the highest level is (86.3, 117]. We can also see which level each row falls into, the first two rows being in the low level for hdl, the third row being in the middle level and so on. We can then add this as a new factor variable, hdl_level, and represent each level with the labels \"low\", \"mid\" and \"high\" using the code below. chol_full$hdl_level &lt;- factor(cut(x = chol_full$hdl, breaks = 3, include.lowest = TRUE), labels = c(&quot;low&quot;, &quot;mid&quot;, &quot;high&quot;)) head(chol_full) id ldl hdl trig age gender smoke weight height bmi hdl_level P912 175 25 148 39 female no 90.77 1.69 31.78110 low P215 196 36 92 32 female no 75.06 1.75 24.50939 low P063 139 65 NA 42 male NA 73.99 1.84 21.85432 mid P117 162 37 139 30 female ex-smoker 86.25 1.83 25.75473 low P613 140 117 59 42 female ex-smoker 76.95 1.81 23.48829 high P332 147 51 126 65 female ex-smoker 57.66 1.75 18.82776 low Sections 1.11.2 Creating New Variables in a Data Frame and 1.13 Tables of Probability and Statistics with R describe how to create new variables. 3.7 Merging data frames Sometimes information relating to the same subjects or observations might be stored in two separate data frames. When this is the case it is easy to combine two data frames using the merge() function. merge() takes the following arguments: x =: this is the first of the two data frames you want to merge together. y =: this is the second of the two data frames you want to merge. by.x =: this specifies which column in the first data frame should be used to merge. This is usually an identifying variable such as subjects' names or ID codes. by.y =: this specifies which column in the second data frame should be used to merge. all =: this takes values TRUE or FALSE, indicating whether all rows from both data frames should be included. all.x =: this takes values TRUE and FALSE, indicating whether extra rows should be created in the second data frame so that all rows in the first data frame are kept. all.y =: this takes values TRUE and FALSE, indicating whether extra rows should be created in the first data frame so that all rows in the second data frame are kept. Only the arguments x = and y = are required. When any of of the by. = arguments are left out of the function, R will automatically look for columns which share the same name in the two data sets. When any of the all. = arguments are left out, they default to FALSE, so only complete cases are kept in the final merged data frame. The file treatment.csv contains information on whether patients in a study testing a new treatment for high cholesterol were given the new drug or a placebo drug with no effect. Some of the patients in this new study are subjects from the chol data frame. We can read in the file treatment.csv and merge it with chol_full in order to see all the information available on a subject. To start with, we need to read in treatment.csv and save this as a data frame called treatment. treatment &lt;- read.csv(file = &quot;treatment.csv&quot;) Then we can merge chol_full and treatment into a single data frame called patients using the following code. patients &lt;- merge(x = chol_full, y = treatment, by.x = &quot;id&quot;, by.y = &quot;patient_id&quot;, all = TRUE) head(patients[, -c(1:3)]) trig age gender smoke weight height bmi hdl_level treatment 120 48 male current 99.02 1.70 34.26298 mid NA NA 42 male NA 73.99 1.84 21.85432 mid Treatment NA NA NA NA NA NA NA NA Treatment 67 48 female no 74.90 1.61 28.89549 mid Treatment NA NA NA NA NA NA NA NA Treatment 139 30 female ex-smoker 86.25 1.83 25.75473 low Placebo Because the column showing the patient ID has a different name in chol_full and treatment, we have had to specify what it is called in each data frame here using by.x = and by.y = (make sure to check the contents of your data frames to notice things like this!). The argument all = TRUE means that we are keeping all information from both data frames, regardless of whether a patient only appears in chol_full or only in treatment. This is why in the excerpt of patients above, there are rows where the value for all variables except treatment are NA. The file class.csv contains information on the average primary class size in the years 2016 - 2022. Read this file into R and save it as a data frame called class. Merge the information from the data frames education and class together into a new data frame called primary, showing all variables from education and the average class size for primary schools only. Look carefully at which row names these two data frames have in common. For more information on merging data set, see Section 1.11.4 Merging Data Frames of Probability and Statistics with R. "],["functions.html", "4 Functions 4.1 Probability functions 4.2 Flow control 4.3 Creating functions", " 4 Functions We have already seen and used many R functions. Now we are going to learn about some more statistics specific functions, as well as how to write our own functions which will give us a lot of flexibility with what we can do in R. 4.1 Probability functions There are a range of functions we can use which make working with statistical distributions a lot easier. We are able to generate random numbers from a distribution, calculate cumulative probabilities, compute densities and return quantiles with them. The name of the distribution you are using is going to be part of the function name, so to keep things simple, let's start by looking at the normal distribution. The four functions you can use with the normal distribution are: rnorm(n, mean = 0, sd = 1): this returns a random sample of size n from a \\(N\\sim(0,\\,1)\\) distribution. pnorm(q, mean = 0, sd = 1): this computes the probability \\(\\mathbb{P}(X\\leq q)\\), where \\(X\\sim N(0,\\,1)\\). dnorm(x, mean = 0, sd = 1): this computes the value of the probability density function, \\(f(x)\\). qnorm(p, mean = 0, sd = 1): this computes the quantile \\(x\\) such that \\(\\mathbb{P}(X\\leq x)=p\\), where \\(X\\sim N(0,\\,1)\\). Note that norm in each function name is because we are using the normal distribution. This part of the function names can be changed based on the distribution we want to use. For example rt(), rbinom() and rf() each return random samples from the \\(t\\), binomial and \\(F\\) distributions, respectively, provided suitable arguments are give - remember to use the help() function to see what arguments are needed. The arguments mean = 0 and sd = 1 are the default values, so leaving them out of any of the functions for the normal distribution above means you will be using the \\(N(0,\\,1)\\) distribution. You can change the mean or standard deviation of the distribution by changing the values assigned to the arguments. The values that pnorm(q), qnorm(p) and dnorm(x) return are summarised graphically in Figure 4.1. Figure 4.1: Summary of probability functions for the standard normal distribution. For example, we know that the 97.5th quantile of the \\(N(0,\\,1)\\) distribution is roughly 1.96. We can double check this using the following code. qnorm(0.975) [1] 1.959964 Choose the correct function and complete the code for the following scenarios. You want to construct a 90% confidence interval so need to know the 95th quantile of the standard normal distribution. rnormpnormdnormqnorm(, mean = 0, sd = 1) How would you find the value of \\(x\\) such that \\(\\mathbb{P}(X\\leq x)=0.45\\), where \\(X\\sim N(100,\\,4^2)\\)? rnormpnormdnormqnorm(0.45,) You want to know the proportion of the \\(N(0,\\,2^2)\\) distribution that lies below -2. That is, \\(\\mathbb{P}(X\\leq -2)\\), where \\(X\\sim N(0,\\,2^2)\\). rnormpnormdnormqnorm(, mean = 0, sd =) The normal distribution is not the only one that we can use the four functions introduced above with. Table 4.1 shows some other distributions that can be used. In order to use a different distribution, simply change the norm part in the function name to the distribution's R name. Change the arguments mean = and sd = to the relevant arguments for your chosen distribution as well. Table 4.1: Distribution names and arguments to use with probability functions. Distribution R Name Arguments Normal norm mean = 0: the mean with default value 0. sd = 1: the standard deviation with default value 1. Binomial binom size =: the number of trials. prob =: the probability of success for each trial. Exponential exp rate = 1: the value of \\(\\theta\\) with default value 1. Geometric geom prob =: the probability of success in each trial. Hypergeometric hyper m =: the number of objects of type I in the population. n =: the number of objects not of type I in the population. k =: the size of the sample taken from the population. Negative Binomial nbinom size =: the number of successful trials you want to observe. prob =: the probability of success in each trial. Poisson pois lambda =: the value of \\(\\lambda\\). Student's t t df =: the degrees of freedom. Uniform unif min = 0: the lower limit of the distribution with default value 0. max = 1: the upper limit of the distribution with default value 1. Chi-square chisq df =: the degrees of freedom. To read more, see Section 1.15 Probability Functions in Probability and Statistics with R. 4.2 Flow control Flow control is the term used to describe the order that your code is carried out. Usually this just happens line by line, but there may be cases where you want to repeat and update certain code over and over. To save you time having to type out a lot of repeating code, there are functions in R which can help you to repeat certain operations. The for() function allows you to repeat lines of code for a given number of repetitions. Sometimes using the for() function is referred to as a for loop because once you have run multiple lines of code, it loops back to the beginning and does it all again. The setup is: for(name in vector){ statements } name: this is the name you want to use for the index in each iteration of the repeated statements. Most commonly this is given the value i. vector: this is a vector which is the same length as the number of times you want to repeat the statements. statements: these are the lines of code you want to repeat a number of times. In order to fully understand how the for() function works, let's look at an example. We could use the for() function to print the numbers 1 up to 5. for(i in 1:5){ print(i) } [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 Here, we have assigned the value i to the name argument and the vector is 1:5. The : operator returns the sequence of numbers from 1 to 5 in this case. The for loop will first of all give i the value 1 and then run the statements within { }, so here it will run print(1). print() is a function we haven't seen yet, but it just 'prints' the arguments to the R console so we will see the value 1 written there. Next, the for loop will update the value of i to the next one given in the vector argument i.e. it will assign the value 2 to i. Then it will again run print(2) and update the value of i again. This will repeat until i has taken all the values given in the vector argument. Complete the following code to sum together the numbers 1 to 12. sum &lt;- for(i in){ sum &lt;- sum + } Using the above code, what is the value of \\(1+2+3+...+12\\)? You might not always know how many times you want to repeat certain lines of code. When this is the case the while() function can be used to repeat code while a given condition is satisfied. Once this condition is no longer TRUE, the loop will stop. The while() function has a similar setup to for loops. while(condition){ statements } condition: this is logical statement that can take the values TRUE or FALSE. When it is true, the statements will be repeated. When it is FALSE, the statements will not be evaluated. statements: these are the lines of code you want to repeat a number of times. We could use a while loop to calculate the sum of the numbers 0, 1, 2, 3, 4, 5, ... up until their total first goes over 100. The code below does this by first creating the vectors i, which lists all the values we want to sum together, and total, to keep track of the sum of all the values in i. Initially i only contains the value 0 and total is also set to 0. Because we only want to sum together the values in i until total first goes over 100, the condition we provide within while() is total &lt; 100 which means the while loop will continue to run only while the value of total is less than 100. Because i starts as only 0 and total is set to 0, the first iteration of the while loop updates i to be \\(\\begin{bmatrix}0&amp;1 \\end{bmatrix}^\\intercal\\) and then it updates total to now also be 1 (since this is the sum of all the values currently in i). The second iteration then extends i to be \\(\\begin{bmatrix}0&amp;1&amp;2 \\end{bmatrix}^\\intercal\\) and updates total again to be \\(0+1+2=3\\). Within the while loop, we continuously extend i by adding the next number in the sequence to the end of it. This is done using the function max() which looks at all values in a vector and returns the maximum. We then update total to be the sum of all the values in i. This is done by using the function sum() which sums together all values in a numeric vector. This continues until total reaches a value which is greater than 100, at which point the while loop stops. The final line prints the final versions of i and total so we can see that the vector i contains the values 0 up to 14 and that the sum of all these values, given by total is 105. i &lt;- 0 total &lt;- 0 while(total &lt; 100){ i &lt;- c(i, max(i)+1) total &lt;- sum(i) } list(&quot;i&quot; = i, &quot;total&quot; = total) $i [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $total [1] 105 If statements are another useful form of flow control. They have a very similar set up to the for() and while() functions. if(condition){ statements } else { statements } condition: this is a logical statement that can take the values TRUE or FALSE. If the condition is TRUE then the statements in the { } immediately after will be evaluated. else: this is an optional part of the if statement. If there is code you wish to run when the condition is FALSE, it is placed in the { } after this statement. For example, we can write code to tell us whether a random value generated from the standard normal distribution lies in the region [-1, 1] using the following code. x &lt;- rnorm(n = 1, mean = 0, sd = 1) if(x &gt;= -1 &amp; x &lt;= 1){ print(&quot;x is in the region [-1, 1]&quot;) } else { print(&quot;x is not in the region [-1, 1]&quot;) } [1] 0.1112213 [1] &quot;x is in the region [-1, 1]&quot; What would the value of y be after running the following if statement? Try to answer without running the code yourself. x &lt;- -4 if(x &gt; 0){ y &lt;- x^2 } else { y &lt;- -(x^2) } You can read more about for loops, while loops and if statements in Section 1.16 Flow Control of Probability and Statistics with R. 4.3 Creating functions So far we have used a number of in built functions in R. It is also possible to create your own functions, specifying the required arguments and what it does. The setup for creating your own function using function() is as follows. fname &lt;- function(argument1, argument2, ...){ expression } fname: this is the name you want to give to your function. It can be anything you choose but try not to use names of functions that already exist. argument1: this is the name of the first argument to be given when you use your function. You can add as many arguments as is necessary for your function to work. expression: this is what you want your function to evaluate. You write this out using the argument names you have specified. For example, we can write a function, normal(), that: draws n random values from a normal distribution with mean m and standard deviation s orders them from smallest to largest for each random value \\(x\\), returns the probability \\(\\mathbb{P}(X\\leq x)\\) and the value of the probability density function at this value, \\(f(x)\\) normal &lt;- function(n, m = 0, s = 1){ x &lt;- rnorm(n = n, mean = m, sd = s) x &lt;- sort(x) prob &lt;- pnorm(q = x, mean = m, sd = s) pdf &lt;- dnorm(x = x, mean = m, sd = s) cbind(x, prob, pdf) } Here we have specified default values of m = 0 and s = 1 in our function. This means that if someone uses the function normal without specifying values for these arguments, then it will automatically use m = 0 and s = 1. Note that any vectors we create within the expression for the function are not saved to your Environment tab. We can then use this new function normal() to see this information for 5 random values from the \\(N(200, 40)\\) distribution. normal(n = 5, m = 200, s = 40) x prob pdf [1,] 194.7766 0.4480522 0.009888883 [2,] 201.2908 0.5128713 0.009968366 [3,] 204.4489 0.5442796 0.009912060 [4,] 234.8700 0.8083276 0.006820707 [5,] 268.3736 0.9563059 0.002314091 The arguments you use within a function can be either 'named' or 'positional'. Named arguments are ones where you use the name given in the setup of the function. For example, in our function normal(), the argument for the mean is called m. You can change the value of the mean using m = 4 within the normal() function for example. Positional arguments are ones where you don't use the name of the argument given in the setup of the function. For example, we could replicate the above output using the following code where the argument names have not been used. normal(5, 200, 40) x prob pdf [1,] 194.7766 0.4480522 0.009888883 [2,] 201.2908 0.5128713 0.009968366 [3,] 204.4489 0.5442796 0.009912060 [4,] 234.8700 0.8083276 0.006820707 [5,] 268.3736 0.9563059 0.002314091 The important thing to remember when using positional arguments is that they are in the same order that their names are specified in the setup of the function so R knows how to match up the values correctly. For example, in the normal() function, the mean needs to be the second argument specified and the standard deviation needs to be the third. For more information on writing your own functions in R, see Section 1.17 Creating Functions in Probability and Statistics with R. "],["exercises.html", "5 Further Exercises Exercise 1 Exercise 2 Exercise 3", " 5 Further Exercises Exercise 1 The file \"NHSScotland.txt\" contains data on the number of patients attending A&amp;E every month in each of the 14 Scottish NHS boards, from 2007 up to 2023. This data set has the following variables: \"Date\": the end of the month that patient numbers are aggregated over. \"NHSBoard\": the Scottish NHS board the patients are from. \"TotalAttendances\": the total number of patients attending A&amp;E in a given month and NHS board. \"Within4Hours\": the number of patients whose wait time was less than 4 hours. \"Over4Hours\": the number of patients whose wait time was greater than 4 hours. \"Over8Hours\": the number of patients whose wait time was greater than 8 hours. \"Over12Hours\": the number of patients whose wait time was greater than 12 hours. Read \"NHSScotland.txt\" into R and save it as a data frame called nhs. Change the column \"NHSBoard\" to be a factor. (Hint: you can see the names of all the Scottish NHS boards using the code unique(nhs$NHSBoard).) Add an additional column to nhs which calculates the percentage of total patients in A&amp;E whose wait time is less than 4 hours. Call this new variable \"PercentageWithin4Hours\". What is the average percentage of patients who had to wait less than 4 hours in each of the 14 Scottish NHS boards? (Hint: think how you can use the tapply() function.) Create a new data frame, called glasgow, which is a subset of nhs. This data set should only show observations from NHS Greater Glasgow &amp; Clyde, as well as only having the variables \"Date\", \"TotalAttendances\" and \"Over4Hours\". Sort glasgow in order of decreasing number of patients who had to wait more than 4 hours in A&amp;E. When did the greatest number of patients have to wait for longer than 4 hours? The file \"HBPopulation.csv\" contains data relating to the population size (in 2021) of each of the 14 Scottish NHS boards. Read this file into R and save it as a data frame called population. Merge nhs and population so that A&amp;E attendance and the health board population size can be seen in the same data frame. Exercise 2 Draw a random sample of 100 values from the \\(\\mbox{Poisson}(3)\\) distribution and save these in a vector x. If any of these random values are less than 3, use a for loop containing an if statement, to change these value to be equal to 3. Exercise 3 The volume of a cylinder is calculated as \\(V_{\\mbox{cylinder}}=\\pi r^2h\\) where \\(r\\) is the radius of the cylinder and \\(h\\) is the height. Write a function called cyl.vol which takes the arguments r and h and returns the volume of cylinder with radius r and height h. Use your function to find the volume of a cylinder with which has radius 2.8cm and height 24cm. Use your function cyl.vol to write another function which can be used to calculate the total volume of \\(n\\) cylinders of the same size. This second function should take the arguments r for the radius, h for the height and n for the number of cylinders. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
