[["index.html", "S2S Lab 1 1 R and RStudio 1.1 Installing R 1.2 Installing RStudio 1.3 Using RStudio", " S2S Lab 1 1 R and RStudio Welcome to the first S2S lab! Today you will be introduced to R and RStudio and learn how to use them both to define and manipulate your own vectors. R is a programming language that you will use to write code in numerous statistics courses throughout your degree. RStudio is an accompaniment to R, known as an Integrated Development Environment (IDE). RStudio essentially makes all features of the R programming language easier to use and it is the software you will interact with in these labs, rather than R directly. It is best for you to install R and RStudio on your own device and use this for all of the labs, but if you would prefer, R and RStudio are always available from the desktop PCs in the lab. If you do not already have R or RStudio downloaded on your device, follow the steps outlined below. 1.1 Installing R The first step is to install R onto your device. This can be done for free from CRAN (the Comprehensive R Archive Network). R is available for Windows, Mac OS, Linux and some other less common operating systems. If you are using a Windows device, follow this link and click 'Download R-x.y.z for Windows' to download the installer for the latest version of R. Once this is complete, run the installer and accept all default settings. If you are using a Mac, follow this link and select the .pkg file from the left of the screen to download the installer for the latest version of R. Once this download is complete, open the file and complete the onscreen steps to finish installing R. 1.2 Installing RStudio Now that R is installed on your device, you are ready to download and install RStudio. To do this, go to RStudio and click on the link 'Download RStudio...'. This should automatically detect what system your device is using but make sure to double check it says either for Windows or for MacOS - whichever is correct! This file may take a while to download, but once it has launch the installer and follow the steps to complete the installation. You are now ready to use RStudio. Make sure you launch the RStudio app to complete the labs, rather than R. 1.3 Using RStudio Once you have opened the RStudio app, create a new text file (called an \"R script\") by: clicking in the top left of the RStudio window selecting from the drop down menu options This will open a new pane in the RStudio window which is where you will write all of your code. RStudio is arranged with four panes, the default layout of which you can see below. RStudio window This is the source pane. This is where you will view, write and edit all your code and view data in a spreadsheet format. Typically this pane isn't displayed when you first launch RStudio; instead, you need to open a new (or pre-existing) R script or load in some data. We 'run' code from here by selecting the row(s) we want to execute and clicking the icon in the top right of this pane (alternatively hold the ctrl key (or cmd on Mac) and hit enter at the same time). This is the console pane. This is where you can view the outcome of any code you have run, as well as type in commands and view output messages such as warnings or errors from code that doesn't work correctly. This pane has several different tabs, but the most used one is the Environment tab. This lists some information about the objects you have created in your code, such as data frames, vectors or statistical models. This pane also has several tabs. The ones of note here are the Files tab which shows the folders and files the current RStudio session has access to, the Plots tab which shows any plots or graphs you have created in your code, and the Help tab which can be used to learn more about the properties of different functions R code is able to use. To save an R script with any code you have written, simply click the icon at the top left of the source pane and choose where to save the file (make sure this is somewhere you can find it again, like in a folder called 'S2S Labs'!). R scripts are saved as .r files. To open a previously saved R script, either click on the .r file in the folder you've saved it to, or within RStudio go to File &gt; Open File... and choose the .r file from there. Now you are ready to begin using RStudio to write your own code! "],["vectors.html", "2 Vectors 2.1 Addition 2.2 Logical operators 2.3 Other types of vectors 2.4 Indexing vectors 2.5 Sequences 2.6 Repeating constants 2.7 Filtering Vectors 2.8 Getting Help", " 2 Vectors Vectors are fundamental in R. They allow you store data of numerous different types, whether that be numbers, text or logical statements, and easily complete mathematical operations or extract certain elements of the data. Let's create some vectors in R to explore their properties. Copy and run the following code in your own R script. x &lt;- 3 y &lt;- c(2, 4, 1) You should notice that two 'Values' appear in the Environment tab, x and y. This is because we have assigned values to each of these names using the &lt;- operator in the code above. x is the single value 3, which can be thought of as a vector of length 1. y is a vector of length 3 and of the form \\(\\begin{bmatrix}2&amp;4&amp;1 \\end{bmatrix}^\\intercal\\). The function c() has been used to 'combine' these values into one vector. 2.1 Addition We can also use R to add vectors together. Let's try it out by running the following code. x + y [1] 5 7 4 The output shown above should appear in the console at the bottom left of the RStudio window. Here, R has 'recycled' the element of the vector x until it is the same length as the vector y, and elementwise addition has then been completed. This essentially means R has completed \\(3+2\\) to calculate the first element, \\(3+4\\) to find the second and \\(3+1\\) to find the third. What happens if we try to add together two vectors of unequal length, but they both have more than one element? We can try this out by creating a new, longer vector \\(z=\\begin{bmatrix}3&amp;3&amp;5&amp;8&amp;2\\end{bmatrix}^\\intercal\\) and then adding this to y. z &lt;- c(3, 3, 5, 8, 2) y + z Warning in y + z: longer object length is not a multiple of shorter object length [1] 5 7 6 10 6 We now see a warning message telling us that the length of vector z is not a multiple of the length of vector y - in other words, they have a different number of elements. We still see a result however (5, 7, 6, 10, 6) so the vectors have been added together. This time, R recycles each element of y in turn until it is the same length as z and then completes the elementwise addition. y has been extended by adding its first two elements on to the end so that it has five entries like z, meaning R has completed the calculation \\(\\begin{bmatrix}2&amp;4&amp;1&amp;2&amp;4\\end{bmatrix}^\\intercal+\\begin{bmatrix}3&amp;3&amp;5&amp;8&amp;2\\end{bmatrix}^\\intercal\\). Create and save the vector \\(a=\\begin{bmatrix}2&amp;2&amp;-1\\end{bmatrix}^\\intercal\\) and scalar \\(b=2\\), then add these together and save the result as a new vector called c. Solution a &lt;- c(2, 2, -1) b &lt;- 2 c &lt;- a + b c [1] 4 4 1 2.2 Logical operators Vectors can contain logical values (TRUE/FALSE) rather than numerical values. We can create logical vectors by comparing the values within a numerical vector. x &lt; y [1] FALSE TRUE FALSE Here, R has again recycled the element from x to make it the same length as y, then it returns a vector telling us for which elements the statement x &lt; y is true. For example, the first element of y is 2 which is less than 3, so x &lt; y is FALSE. Other logical operators that we can use with vectors include: Operator Function &gt; greater than &lt; less than &lt;= less than or equal to &gt;= greater than or equal to == exact equality != exact inequality &amp; vector intersection | vector union &amp;&amp; scalar intersection || scalar union Let's explore how these operators behave by creating two new logical vectors. s &lt;- c(TRUE, TRUE, FALSE) t &lt;- c(FALSE, TRUE, TRUE) Write some code to find: the intersection the vectors s and t. the union of vectors s and t whether the elements of s and t are unequal Solution Intersection: s &amp; t [1] FALSE TRUE FALSE We can see that the operator &amp; returns a TRUE statement only when both elements being compared are TRUE. Union: s | t [1] TRUE TRUE TRUE The | operator returns a TRUE statement when either of the elements being compared are TRUE Inequality: s != t [1] TRUE FALSE TRUE The != operator returns a TRUE statement only when both elements are different. Try using some of the other operators listed above to see if they return the vectors you expect. What if we wanted to compare specific elements of the vectors? We can achieve this by 'indexing' the vector, in other words we choose a single element from the vector that we want to use. This is done by first telling R which vector we want to look at by typing its name and then specifying the element we want by including its position inside square brackets ([ ]). For example, z[4] would extract the fourth element from z, that is the number 8. The following code can be used to check whether the second element of s is the same as the third element of t. s[2] == t[3] [1] TRUE Note: since we have chosen only one element of the vectors here, this is when we would use the scalar logical operators &amp;&amp; and || to find the intersection and union respectively. Create the vectors \\(u=\\begin{bmatrix} 4 &amp; 4 &amp; 1 \\end{bmatrix}^\\intercal\\) and \\(v=\\begin{bmatrix} 1 &amp; 0 &amp; 5 \\end{bmatrix}^\\intercal\\). Write code to check whether the first elements of u+v and x+y are the same. if the third element of u+v is the same as the second element of x+y. Solution u &lt;- c(4, 4, 1) v &lt;- c(1, 0, 5) (u + v)[1] == (x + y)[1] #checking equality of the first elements [1] TRUE Here we have wrapped both u+v and x+y in brackets first so that we can then index the resulting vector. Alternatively, you could save u+v and x+y as new vectors, called something different, using the &lt;- operator. u+v is equal to \\(\\begin{bmatrix} 5 &amp; 4 &amp; 6 \\end{bmatrix}^\\intercal\\) so its first element is 5. x+y is equal to \\(\\begin{bmatrix} 5 &amp; 7 &amp; 4 \\end{bmatrix}^\\intercal\\) so its first element is also 5. It makes sense then that a TRUE statement is returned when checking the equality of the first elements of these two vectors. (u + v)[3] == (x + y)[2] #checking equality of the third and second elements respectively [1] FALSE Similarly, we can see that the third entry of u+v is 6 and the second entry of x+y is 7. Since these are clearly not equal we would expect R to return a FALSE statement when checking their equality, which we can see above. 2.3 Other types of vectors So far we have looked at numeric vectors and logical vectors. R can also store vectors with other types of elements, for example a character vector can be used to store strings of text. The code below shows how to create a character vector; animals &lt;- c(&quot;dog&quot;, &quot;sheep&quot;, &quot;cow&quot;, &quot;horse&quot;) Vectors containing complex numbers can also be created as follows; complex &lt;- c(2+1i, 0+0i, 3+2i) The function typof() is going to be useful for checking how R has stored the elements of a particular vector. To check the type of vector animals is, we can run the code; typeof(animals) [1] &quot;character&quot; This tells us that R has stored animals as a character vector, meaning each element is stored as a string of text. What type of vector is s? logicalnumericcomplexcharacter What happens if we try to combine two vectors which are of different types in R? Let's run some code and see. c(t, y) #t is a logical vector and y is a numeric vector [1] 0 1 1 2 4 1 Here R has returned the vector \\(\\begin{bmatrix} 0&amp;1&amp;1&amp;2&amp;4&amp;1 \\end{bmatrix}^\\intercal\\), rather than \\(\\begin{bmatrix} \\mbox{FALSE} &amp; \\mbox{TRUE} &amp; \\mbox{TRUE} &amp; 2 &amp; 4 &amp; 1 \\end{bmatrix}^\\intercal\\) as might be expected. So what's happened? When R combines vectors of different types it will ensure all the elements are of the same type as this is how vectors need to be stored in R. This is done so that all elements are of the most 'complex' type. R considers numeric vectors to be more complex than logical vectors, so when we combine a logical and a numeric vector we will be left with a numeric vector. The entries TRUE and FALSE within the vector t therefore need to be presented numerically. A FALSE statement will take the value 0 and a TRUE statement will take the value 1. Let's look at combining a numeric vector with a complex vector. c(y, complex) #y is a numeric vector and &#39;complex&#39; is a vector containing complex numbers [1] 2+0i 4+0i 1+0i 2+1i 0+0i 3+2i Now all elements are presented as a complex number. That is because R considers complex vectors to be more complex than numeric vectors. Create a new vector, called combined, which is a combination of the logical vector s and the character vector animals. What type of vector is this? Solution combined &lt;- c(s, animals) [1] &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;dog&quot; &quot;sheep&quot; &quot;cow&quot; &quot;horse&quot; typeof(combined) [1] &quot;character&quot; The resulting vector is \\(\\begin{bmatrix} \\mbox{&#39;TRUE&#39;} &amp; \\mbox{&#39;TRUE&#39;} &amp; \\mbox{&#39;FALSE&#39;} &amp; \\mbox{&#39;dog&#39;} &amp; \\mbox{&#39;sheep&#39;} &amp; \\mbox{&#39;cow&#39;} &amp; \\mbox{&#39;horse&#39;} \\end{bmatrix}^\\intercal\\) which we can see is stored by R as a character vector. Each element is now considered to be a string of text (note the quotation marks around each element). It is possible to coerce vectors of one type to be another type. This can be done using one of the functions as.logical() as.numeric() as.complex() as.character() For example, if we wanted to change the logical vector s to be a numeric vector we could use the following code. as.numeric(s) [1] 1 1 0 We again see that TRUE statements have been given the value 1 and FALSE statements have been given the value 0. It is important to ensure that this coercion makes sense to do! It doesn't make much sense to represent the vector animals as a numerical vector, and in fact if we tried to R would show us a warning message. as.numeric(animals) Warning: NAs introduced by coercion [1] NA NA NA NA R has still changed the vector to be numeric, but since \"dog\", for example, doesn't have a numerical value it has been represented with NA. This tells us that each element of the now numeric vector doesn't have a value. 2.4 Indexing vectors We have seen briefly how to index vectors using square brackets ([ ]) but we can now look at indexing in more detail. Specific elements can be extracted using positive indices or can be omitted from a vector using negative indices. Let's again look at the vector z (remember \\(z=\\begin{bmatrix}3&amp;3&amp;5&amp;8&amp;2 \\end{bmatrix}^\\intercal\\)) and extract the first two elements. z[c(1, 2)] [1] 3 3 If we wanted to remove the third entry from z we can use the following code. z[-3] [1] 3 3 8 2 Note that it is not possible to use both positive and negative indices at the same time, so we couldn't remove the first entry of a vector at the same time as extracting the second and third entries for example. Complete the code that would remove the third and fourth elements from the vector animals. animals[] Hint There are several ways this code could be written. We can remove the third and fourth entries through either of the following lines of code. animals[-c(3, 4)] [1] &quot;dog&quot; &quot;sheep&quot; animals[c(-3, -4)] [1] &quot;dog&quot; &quot;sheep&quot; Alternatively, because animals has four elements, removing the third and fourth elements is equivalent to extracting the first and second elements. Therefore we can achieve the same results using the following code. animals[c(1, 2)] [1] &quot;dog&quot; &quot;sheep&quot; This task has three steps, so you should write three lines of code. Create the vector \\(\\begin{bmatrix} 1&amp;1&amp;0&amp;1 \\end{bmatrix}\\) and call it binary Change binary to be a logical vector and save this as a new vector called logical Extract the first and third elements of this vector logical. Solution binary &lt;- c(1, 1, 0, 1) logical &lt;- as.logical(binary) logical[c(1, 3)] [1] TRUE FALSE In the above code we have chosen to extract the first and third elements. Alternatively, we could remove the second and fourth elements instead. logical[-c(2, 4)] [1] TRUE FALSE 2.5 Sequences So far we have manually entered the elements of all the vectors we have created. If a vector is simply a sequence of numbers (following some pattern), R has some nice functions which will speed up how we create these vectors. The operator from:to can be used to generate a sequence of integers from the number on the left hand side (from), up to the number on the right hand side (to). All we need to do is change the values of from and to. The following code generates a sequence of integers from 2 up to 8. 2:8 [1] 2 3 4 5 6 7 8 This can be useful if we want to extract (or omit) a sequence of elements from a vector which are all next to each other. Let's start by creating quite a long vector (the code letters in R will generate a vector of all 26 lowercase letters of the alphabet). If we then want to extract the first five letters of the alphabet, we can use the code 1:5 within our indexing. The following code shows how this is done. longvector &lt;- letters longvector[1:5] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; What if we want to generate a non-consecutive sequence of numbers? What about a sequence of non-integer values? We can do this using the function seq() in R. A function is a piece of code that tells R to complete some predetermined steps which will depend on the values provided to some 'arguments' within the brackets ( ). The arguments that the function seq() can be provided with are: from =: this is the starting value of our sequence (it can be an integer or a non-integer) to =: this is the final value of our sequence (it can be an integer or a non-integer) by =: this is the size of the jump between consecutive numbers in our sequence length.out =: this is the total number of values we want to be included in our sequence Hopefully you can see that if we specify each of to =, by = and length.out = then they might not necessarily all match up. Therefore we actually only need to specify two of to =, by = or length.out = within the seq() function. Let's look at some examples of using seq(). seq(from = 2, to = 4, by = 0.2) [1] 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 seq(from = 3, to = 5, length.out = 9) [1] 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 seq(from = 4, by = 0.5, length.out = 7) [1] 4.0 4.5 5.0 5.5 6.0 6.5 7.0 Write some code to create the sequence 4.10, 4.15, 4.20, 4.25, 4.30, 4.35, 4.40 using the function seq() Solution There are three different ways we could generate this sequence using the seq() function. seq(from = 4.10, to = 4.40, by = 0.05) [1] 4.10 4.15 4.20 4.25 4.30 4.35 4.40 seq(from = 4.10, to = 4.40, length.out = 7) [1] 4.10 4.15 4.20 4.25 4.30 4.35 4.40 seq(from = 4.10, by = 0.05, length.out = 7) [1] 4.10 4.15 4.20 4.25 4.30 4.35 4.40 2.6 Repeating constants Another function in R that's going to be useful is the rep() function. This allows us to create a vector which consists of repeated elements, or repeated sequences of elements. The arguments that rep() can be provided with are: x =: this is value (or sequence) that we want to be repeated times =: this is the number of times the value should be repeated - if x is a sequence then the full sequence will be repeated this many times each =: if x is a sequence then this is the number of times the first element of the sequence should be repeated before moving on to repeating the second element and so on length.out =: this is the total number of elements we want to be included in the vector of repeated values If we specify all of times =, each = and length.out =, they might not necessarily be in agreement with each other. Therefore, only one of times =, each = or length.out = needs to be specified. Let's look at some examples of using rep(). rep(x = 2, times = 6) [1] 2 2 2 2 2 2 rep(x = 1:3, each = 2) [1] 1 1 2 2 3 3 rep(x = 1:4, times = 1:4) [1] 1 2 2 3 3 3 4 4 4 4 rep(x = c(TRUE, FALSE), length.out = 8) [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE Write some code to create each of the following repeating sequences using rep(): 3, 4, 5, 3, 4, 5, 3, 4, 5 2, 2, 4, 4, 6, 6 blue, blue, blue, red, red Solution rep(3:5, times = 3) [1] 3 4 5 3 4 5 3 4 5 rep(c(2, 4, 6), each = 2) [1] 2 2 4 4 6 6 rep(c(&quot;blue&quot;, &quot;red&quot;), times=c(3, 2)) [1] &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; Write some code to generate the sequence 2, 3, 3, 4, 5, 5, 6, 7, 7 using both the seq() and rep() functions. Hint First of all, notice that the sequence of numbers you want to repeat is 2, 3, 4, 5, 6, 7. Therefore this sequence should be generated using seq(), or the from:to operator, and then fed into the rep() function as the x = argument. Then have a think about how many times each of these elements should be repeated. 2 should be repeated once, 3 should be repeated twice, 4 should be repeated once and so on. To do this, the times = argument within rep() should be given the repeating sequence 1, 2, 1, 2, 1, 2. Solution rep(x = seq(from = 2, to = 7, by = 1), times = rep(x = c(1, 2), times = 3)) [1] 2 3 3 4 5 5 6 7 7 2.7 Filtering Vectors We can combine what we have already learned in terms of logical operators (Section 2.2) and indexing vectors (Section 2.4) in order to extract elements which satisfy certain conditions. For example, if we create the vector \\(\\begin{bmatrix}2 &amp; 2 &amp; 3 &amp; 6 \\end{bmatrix}\\), then we can extract the elements of this vector which are greater than or equal to 3 in one easy step. vect &lt;- c(2, 2, 3, 6) vect[vect &gt;= 3] [1] 3 6 This works because R will initially run the logical operator vect &gt;= 3 which will return the following logical vector. [1] FALSE FALSE TRUE TRUE Using this logical vector to index inside the square brackets returns exactly the same result as above. vect[c(FALSE, FALSE, TRUE, TRUE)] [1] 3 6 Write some code to extract the elements of the vector z which are greater than 5. Solution z[z &gt; 5] [1] 8 A function within R which can be used to give the same results as logical operators within the square brackets is the subset() function. This returns the elements of a specified vector which satisfy a given logical expression. The arguments that subset() can be provided with are: x =: this is the vector we want to extract elements from subset =: this is the logical expression used to select the elements to keep We can use subset() to extract the elements of the vector vect which are greater than or equal to 3, exactly as we did before. subset(x = vect, subset = (vect &gt;= 3)) [1] 3 6 Extract the elements of the vector z which are greater than 5 using the subset() function. Solution subset(x = z, subset = (z &gt; 5)) [1] 8 2.8 Getting Help If you are ever unsure of the arguments required in a particular function in R, or even what that function does, there are ways to find out. R contains extensive help files on any function that can be used. To access these, simply put a ? in front of the function name, or use the function help(). For example, if we were unsure what the function rep() is used for, then we can run either of the following lines of code. ?rep starting httpd help server ... done help(rep) "],["exercises.html", "3 Exercises", " 3 Exercises "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
